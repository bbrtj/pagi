<project_specification>
  <project_name>PAGI::Simple View Layer - Templates, Models, and htmx Integration</project_name>

  <overview>
    Build a comprehensive view layer for PAGI::Simple that provides:

    1. Template rendering using Template::EmbeddedPerl with layouts, partials, and helpers
    2. htmx integration with attribute helpers and automatic fragment detection
    3. Catalyst-style model layer with auto-discovery and dependency injection
    4. Valiant form builder integration (isolated as a composable role)
    5. TO_HTML protocol allowing objects to render themselves

    This creates a modern, productive web development experience combining server-rendered
    HTML with htmx for dynamic interactions - no heavy JavaScript framework required.
    The design draws inspiration from Ruby on Rails, Python FastHTML, Perl Catalyst,
    and modern hypermedia-driven application patterns.

    Design Philosophy:
    - Templates for layouts and complex pages (designer-friendly)
    - Objects can render themselves via TO_HTML protocol (FastHTML-inspired)
    - htmx for interactivity without JavaScript complexity
    - Models encapsulate business logic with clean dependency injection
    - Valiant provides Rails-like validation and form building
    - Progressive enhancement - works without JavaScript, enhanced with htmx
  </overview>

  <technology_stack>
    <runtime>
      <perl_version>5.32+ (required for native subroutine signatures)</perl_version>
      <pragmas>strict, warnings, experimental 'signatures'</pragmas>
    </runtime>

    <core_dependencies>
      <templating>Template::EmbeddedPerl (embedded Perl template engine)</templating>
      <htmx>htmx 2.0.x (bundled JavaScript file)</htmx>
      <model_discovery>Module::Pluggable (auto-discover model classes)</model_discovery>
      <roles>Role::Tiny (lightweight role composition)</roles>
      <validation>Valiant (optional, for form building and validation)</validation>
      <json>JSON::MaybeXS (JSON encoding for responses)</json>
      <uri>URI::Escape (URL encoding)</uri>
      <async>Future::AsyncAwait (async model support)</async>
    </core_dependencies>

    <optional_dependencies>
      <valiant>Valiant::HTML::FormBuilder (form generation)</valiant>
      <valiant_html>Valiant::HTML::Util::Form (form helpers)</valiant_html>
      <valiant_tags>Valiant::HTML::Util::FormTags (low-level form tags)</valiant_tags>
      <dbic>DBIx::Class::Valiant (ORM integration)</dbic>
    </optional_dependencies>

    <bundled_assets>
      <htmx_js>share/htmx/htmx.min.js (htmx 2.0.x)</htmx_js>
      <htmx_ws>share/htmx/ext/ws.js (WebSocket extension)</htmx_ws>
      <htmx_sse>share/htmx/ext/sse.js (SSE extension)</htmx_sse>
    </bundled_assets>

    <testing>
      <framework>Test2::V0</framework>
      <html_testing>Test2::Tools::DOM (DOM assertions)</html_testing>
      <async_testing>Test::Future::IO::Impl</async_testing>
    </testing>
  </technology_stack>

  <module_structure>
    <namespace>PAGI::Simple</namespace>
    <layout>
      lib/
        PAGI/
          Simple.pm                          # Extended with view/model methods
          Simple/
            View.pm                          # Template rendering engine
            View/
              Helpers.pm                     # Built-in template helpers
              Helpers/
                Htmx.pm                      # htmx attribute helpers
                Routes.pm                   # Named route URL generation
                Tags.pm                     # HTML tag helpers
              Layout.pm                     # Layout/extends/block system
              Role/
                Valiant.pm                  # Valiant form builder integration
            Model.pm                        # Base model class
            Model/
              Role/
                PerRequest.pm               # Per-request caching role
            Models.pm                       # Model registry and discovery
            Context.pm                      # Extended with view/model methods
      share/
        htmx/
          htmx.min.js                       # htmx 2.0.x bundled
          ext/
            ws.js                           # WebSocket extension
            sse.js                          # SSE extension
      t/
        view/
          00-view-basic.t                   # Basic template rendering
          01-view-helpers.t                 # Helper functions
          02-view-htmx.t                    # htmx helpers
          03-view-layouts.t                 # Layout system
          04-view-partials.t                # Partial rendering
          05-view-to-html.t                 # TO_HTML protocol
          06-view-auto-fragment.t           # htmx fragment detection
          07-view-caching.t                 # Template caching
        model/
          00-model-basic.t                  # Basic model functionality
          01-model-discovery.t              # Auto-discovery
          02-model-factory.t                # Factory pattern
          03-model-per-request.t            # Per-request caching
          04-model-async.t                  # Async model methods
          05-model-config.t                 # Model configuration
        valiant/
          00-valiant-form-for.t             # form_for helper
          01-valiant-fields-for.t           # Nested forms
          02-valiant-inputs.t               # Input helpers
          03-valiant-errors.t               # Error display
          04-valiant-validation.t           # Validation integration
          05-valiant-htmx.t                 # htmx + Valiant integration
        integration/
          00-todo-app.t                     # Full todo app test
          01-user-crud.t                    # CRUD operations test
          02-nested-forms.t                 # Complex nested forms
    </layout>
  </module_structure>

  <core_concepts>
    <view_system>
      <description>
        Template rendering using Template::EmbeddedPerl with extensions for
        layouts, partials, helpers, and htmx integration.
      </description>

      <template_syntax>
        Templates use embedded Perl syntax:
        - &lt;% code %&gt;           Execute Perl code
        - &lt;%= expression %&gt;   Output expression (auto-escaped)
        - &lt;%== expression %&gt;  Output raw (unescaped)
        - % code                    Line-based Perl code
        - %= expression             Line-based output

        Example:
        ```html
        &lt;ul&gt;
          &lt;% for my $item (@$items) { %&gt;
            &lt;li&gt;&lt;%= $item-&gt;name %&gt;&lt;/li&gt;
          &lt;% } %&gt;
        &lt;/ul&gt;
        ```
      </template_syntax>

      <layout_system>
        Templates can extend layouts using block inheritance:

        ```html
        &lt;!-- templates/layouts/default.html.ep --&gt;
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;&lt;title&gt;&lt;%= $title %&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;%= content %&gt;
        &lt;/body&gt;
        &lt;/html&gt;

        &lt;!-- templates/index.html.ep --&gt;
        &lt;% extends 'layouts/default', title =&gt; 'Home' %&gt;

        &lt;% block content =&gt; begin %&gt;
          &lt;h1&gt;Welcome&lt;/h1&gt;
        &lt;% end %&gt;
        ```
      </layout_system>

      <partials>
        Partials are templates prefixed with underscore:
        - templates/todos/_item.html.ep
        - templates/todos/_form.html.ep

        Include with:
        ```html
        &lt;%= include 'todos/_item', todo =&gt; $todo %&gt;
        ```
      </partials>

      <to_html_protocol>
        Objects implementing TO_HTML method render themselves:

        ```perl
        package MyApp::Entity::Todo;

        sub TO_HTML ($self, $view) {
            $view-&gt;include('todos/_item', todo =&gt; $self);
        }
        ```

        In templates, objects render automatically:
        ```html
        &lt;% for my $todo (@$todos) { %&gt;
          &lt;%= $todo %&gt;  &lt;!-- calls $todo-&gt;TO_HTML --&gt;
        &lt;% } %&gt;
        ```
      </to_html_protocol>
    </view_system>

    <htmx_integration>
      <description>
        First-class htmx support with attribute helpers and automatic
        fragment detection for partial page updates.
      </description>

      <attribute_helpers>
        Template helpers generate htmx attributes:

        ```html
        &lt;button &lt;%= hx_delete('/todos/123',
                              target  =&gt; '#todo-123',
                              swap    =&gt; 'outerHTML',
                              confirm =&gt; 'Delete?') %&gt;&gt;
          Delete
        &lt;/button&gt;
        ```

        Generates:
        ```html
        &lt;button hx-delete="/todos/123"
                hx-target="#todo-123"
                hx-swap="outerHTML"
                hx-confirm="Delete?"&gt;
          Delete
        &lt;/button&gt;
        ```
      </attribute_helpers>

      <auto_fragment_detection>
        When htmx makes a request (HX-Request header present), the view
        automatically renders just the content block without the layout.

        Full page request: renders layout + content
        htmx request: renders only content block

        This is automatic - no code changes needed.
      </auto_fragment_detection>

      <response_helpers>
        Context methods for htmx-aware responses:

        ```perl
        # Render fragment for htmx, redirect for browser
        $c-&gt;render_or_redirect('/todos', 'todos/_item', todo =&gt; $todo);

        # Empty response for htmx, redirect for browser (delete patterns)
        $c-&gt;empty_or_redirect('/todos');

        # Trigger client-side events
        $c-&gt;hx_trigger('todoAdded');
        $c-&gt;hx_trigger('showToast', message =&gt; 'Saved!');

        # Check if htmx request
        if ($c-&gt;req-&gt;is_htmx) { ... }
        ```
      </response_helpers>

      <bundled_extensions>
        htmx extensions for WebSocket and SSE:

        ```html
        &lt;%= htmx() %&gt;      &lt;!-- Core htmx script --&gt;
        &lt;%= htmx_ws() %&gt;   &lt;!-- WebSocket extension --&gt;
        &lt;%= htmx_sse() %&gt;  &lt;!-- SSE extension --&gt;
        ```
      </bundled_extensions>
    </htmx_integration>

    <model_layer>
      <description>
        Catalyst-inspired model layer with auto-discovery, dependency injection,
        and support for both factory pattern and per-request caching.
      </description>

      <auto_discovery>
        Models are auto-discovered from configured namespace:

        ```perl
        my $app = PAGI::Simple-&gt;new(
            model_namespace =&gt; 'MyApp::Model',
        );

        # Auto-discovers:
        # MyApp::Model::Todo     -&gt; $c-&gt;model('Todo')
        # MyApp::Model::User     -&gt; $c-&gt;model('User')
        # MyApp::Model::Foo::Bar -&gt; $c-&gt;model('Foo::Bar')
        ```
      </auto_discovery>

      <factory_pattern>
        By default, $c-&gt;model('Name') returns a fresh instance each call:

        ```perl
        my $m1 = $c-&gt;model('Todo');
        my $m2 = $c-&gt;model('Todo');
        # $m1 != $m2 (different instances)
        ```

        This is the simple, predictable default.
      </factory_pattern>

      <per_request_caching>
        Models can opt-in to per-request caching:

        ```perl
        package MyApp::Model::CurrentUser;
        use parent 'PAGI::Simple::Model';
        use Role::Tiny::With;
        with 'PAGI::Simple::Model::Role::PerRequest';

        # Now cached per request:
        my $u1 = $c-&gt;model('CurrentUser');
        my $u2 = $c-&gt;model('CurrentUser');
        # $u1 == $u2 (same instance)
        ```
      </per_request_caching>

      <async_support>
        Models can use async methods and for_context can be async:

        ```perl
        package MyApp::Model::User;
        use parent 'PAGI::Simple::Model';
        use Future::AsyncAwait;

        async sub for_context ($class, $c, $config) {
            my $db = await $c-&gt;model('DB');
            return $class-&gt;new(db =&gt; $db, c =&gt; $c);
        }

        async sub find ($self, $id) {
            return await $self-&gt;{db}-&gt;query('SELECT * FROM users WHERE id = ?', $id);
        }
        ```

        Usage:
        ```perl
        my $user_model = await $c-&gt;model('User');
        my $user = await $user_model-&gt;find(123);
        ```
      </async_support>

      <configuration>
        Models receive configuration from app setup:

        ```perl
        my $app = PAGI::Simple-&gt;new(
            model_namespace =&gt; 'MyApp::Model',
            model_config =&gt; {
                DB =&gt; { dsn =&gt; 'dbi:Pg:dbname=myapp' },
                Cache =&gt; { host =&gt; 'localhost', port =&gt; 6379 },
            },
        );
        ```
      </configuration>
    </model_layer>

    <valiant_integration>
      <description>
        Optional Valiant integration for form building and validation,
        isolated in a composable role for potential separate distribution.
      </description>

      <form_for>
        Bind forms to model objects with automatic value population and error display:

        ```html
        &lt;%= form_for $todo, {
            action =&gt; route('todos_create'),
            method =&gt; 'POST',
            %{ hx_post(route('todos_create'), target =&gt; '#form', swap =&gt; 'outerHTML') }
        }, sub ($fb) { %&gt;

          &lt;div class="field"&gt;
            &lt;%= $fb-&gt;label('title') %&gt;
            &lt;%= $fb-&gt;input('title', class =&gt; 'form-control') %&gt;
            &lt;%= $fb-&gt;errors_for('title') %&gt;
          &lt;/div&gt;

          &lt;%= $fb-&gt;submit('Save') %&gt;
        &lt;% } %&gt;
        ```
      </form_for>

      <fields_for>
        Nested forms for has_many relationships:

        ```html
        &lt;%= $fb-&gt;fields_for('comments', sub ($cfb, $comment) { %&gt;
          &lt;div class="nested-field"&gt;
            &lt;%= $cfb-&gt;text_area('content') %&gt;
            &lt;%= $cfb-&gt;errors_for('content') %&gt;
            &lt;%= $cfb-&gt;checkbox('_destroy') %&gt; Remove
          &lt;/div&gt;
        &lt;% }) %&gt;
        ```
      </fields_for>

      <validation>
        Models use Valiant validations:

        ```perl
        package MyApp::Entity::Todo;
        use Moo;
        use Valiant::Validations;

        has 'title' =&gt; (is =&gt; 'rw');
        has 'priority' =&gt; (is =&gt; 'rw');

        validates title =&gt; (
            presence =&gt; 1,
            length =&gt; { minimum =&gt; 2, maximum =&gt; 100 },
        );

        validates priority =&gt; (
            inclusion =&gt; [qw(low medium high)],
        );
        ```

        In routes:
        ```perl
        $app-&gt;post('/todos' =&gt; async sub ($c) {
            my $todo = MyApp::Entity::Todo-&gt;new(%params);

            if ($todo-&gt;validate-&gt;valid) {
                $c-&gt;model('Todo')-&gt;save($todo);
                $c-&gt;render_or_redirect('/', 'todos/_item', todo =&gt; $todo);
            } else {
                # Re-render form with errors
                $c-&gt;render('todos/_form', todo =&gt; $todo);
            }
        });
        ```
      </validation>

      <error_display>
        Multiple ways to display validation errors:

        ```html
        &lt;!-- Field-specific errors --&gt;
        &lt;%= $fb-&gt;errors_for('title') %&gt;

        &lt;!-- Custom error rendering --&gt;
        &lt;%= $fb-&gt;errors_for('title', sub ($errors) { %&gt;
          &lt;span class="error"&gt;&lt;%= join ', ', @$errors %&gt;&lt;/span&gt;
        &lt;% }) %&gt;

        &lt;!-- Model-level errors --&gt;
        &lt;%= $fb-&gt;model_errors(sub ($errors) { %&gt;
          &lt;div class="alert"&gt;
            &lt;% for my $err (@$errors) { %&gt;
              &lt;p&gt;&lt;%= $err %&gt;&lt;/p&gt;
            &lt;% } %&gt;
          &lt;/div&gt;
        &lt;% }) %&gt;

        &lt;!-- Conditional CSS class --&gt;
        &lt;div class="field &lt;%= $fb-&gt;attribute_has_errors('title') ? 'has-error' : '' %&gt;"&gt;
        ```
      </error_display>

      <inline_validation>
        htmx-powered inline field validation:

        ```html
        &lt;%= $fb-&gt;input('email',
            %{ hx_post(route('validate_field', field =&gt; 'email'),
                       trigger =&gt; 'blur changed delay:300ms',
                       target  =&gt; 'next .error') }
        ) %&gt;
        &lt;span class="error"&gt;&lt;%= $fb-&gt;errors_for('email') %&gt;&lt;/span&gt;
        ```
      </inline_validation>
    </valiant_integration>

    <named_routes>
      <description>
        URL generation from named routes, accessible in templates and code.
      </description>

      <defining_routes>
        ```perl
        $app-&gt;get('/todos/:id' =&gt; sub ($c) { ... })-&gt;name('todo_show');
        $app-&gt;post('/todos' =&gt; sub ($c) { ... })-&gt;name('todos_create');
        $app-&gt;del('/todos/:id' =&gt; sub ($c) { ... })-&gt;name('todo_delete');
        ```
      </defining_routes>

      <generating_urls>
        In templates:
        ```html
        &lt;a href="&lt;%= route('todo_show', id =&gt; 123) %&gt;"&gt;View&lt;/a&gt;

        &lt;button &lt;%= hx_delete(route('todo_delete', id =&gt; $todo-&gt;id)) %&gt;&gt;
          Delete
        &lt;/button&gt;
        ```

        In code:
        ```perl
        my $url = $c-&gt;url_for('todo_show', id =&gt; 123);
        await $c-&gt;redirect_to('todo_show', id =&gt; 123);
        ```
      </generating_urls>

      <query_parameters>
        ```perl
        route('search', query =&gt; { q =&gt; 'perl', page =&gt; 2 })
        # =&gt; /search?q=perl&amp;page=2
        ```
      </query_parameters>
    </named_routes>
  </core_concepts>

  <api_reference>
    <pagi_simple_extensions>
      <description>New methods added to PAGI::Simple</description>

      <method name="views">
        Configure template rendering:
        ```perl
        $app-&gt;views($template_dir, \%options);

        # Options:
        #   auto_escape =&gt; 1              # HTML escape by default (recommended)
        #   extension =&gt; '.html.ep'       # Template file extension
        #   cache =&gt; 1                    # Cache compiled templates in memory
        #   helpers =&gt; { name =&gt; sub {} } # Custom template helpers
        #   roles =&gt; ['Role::Name']       # Roles to compose into view
        #   development =&gt; 0              # Development mode (no cache, verbose errors)
        ```
      </method>

      <method name="model_namespace">
        Configure model auto-discovery:
        ```perl
        my $app = PAGI::Simple-&gt;new(
            model_namespace =&gt; 'MyApp::Model',
        );
        ```
      </method>

      <method name="model_config">
        Per-model configuration:
        ```perl
        my $app = PAGI::Simple-&gt;new(
            model_config =&gt; {
                ModelName =&gt; { option =&gt; 'value' },
            },
        );
        ```
      </method>
    </pagi_simple_extensions>

    <context_extensions>
      <description>New methods added to PAGI::Simple::Context ($c)</description>

      <method name="render">
        Render a template:
        ```perl
        $c-&gt;render('template_name', key =&gt; $value, ...);
        $c-&gt;render('todos/index', todos =&gt; \@todos);
        ```
        Auto-detects htmx requests and renders fragment vs full page.
      </method>

      <method name="render_string">
        Render template from string (for WebSocket/SSE):
        ```perl
        my $html = $c-&gt;render_string('todos/_item', todo =&gt; $todo);
        ```
      </method>

      <method name="render_or_redirect">
        Render fragment for htmx, redirect for browser:
        ```perl
        $c-&gt;render_or_redirect($redirect_url, $template, %vars);
        ```
      </method>

      <method name="empty_or_redirect">
        Empty 200 for htmx (element removal), redirect for browser:
        ```perl
        $c-&gt;empty_or_redirect($redirect_url);
        ```
      </method>

      <method name="hx_trigger">
        Set HX-Trigger response header:
        ```perl
        $c-&gt;hx_trigger('eventName');
        $c-&gt;hx_trigger('eventName', key =&gt; 'value');
        ```
      </method>

      <method name="hx_redirect">
        Set HX-Redirect response header (client-side redirect):
        ```perl
        $c-&gt;hx_redirect('/new-location');
        ```
      </method>

      <method name="hx_refresh">
        Set HX-Refresh header (full page refresh):
        ```perl
        $c-&gt;hx_refresh;
        ```
      </method>

      <method name="model">
        Get model instance (sync or async):
        ```perl
        my $todos = $c-&gt;model('Todo');           # Sync factory
        my $user = await $c-&gt;model('User');      # Async for_context
        ```
      </method>

      <method name="url_for">
        Generate URL from named route:
        ```perl
        my $url = $c-&gt;url_for('route_name', param =&gt; 'value');
        ```
      </method>

      <method name="redirect_to">
        Redirect to named route:
        ```perl
        await $c-&gt;redirect_to('route_name', param =&gt; 'value');
        ```
      </method>
    </context_extensions>

    <request_extensions>
      <description>New methods added to PAGI::Simple::Request</description>

      <method name="is_htmx">
        Check if request is from htmx:
        ```perl
        if ($c-&gt;req-&gt;is_htmx) { ... }
        ```
      </method>

      <method name="htmx_target">
        Get HX-Target header value:
        ```perl
        my $target = $c-&gt;req-&gt;htmx_target;  # e.g., "#todo-list"
        ```
      </method>

      <method name="htmx_trigger_name">
        Get HX-Trigger-Name header (element that triggered request):
        ```perl
        my $name = $c-&gt;req-&gt;htmx_trigger_name;
        ```
      </method>

      <method name="htmx_current_url">
        Get HX-Current-URL header:
        ```perl
        my $url = $c-&gt;req-&gt;htmx_current_url;
        ```
      </method>

      <method name="htmx_prompt">
        Get HX-Prompt header (user input from hx-prompt):
        ```perl
        my $input = $c-&gt;req-&gt;htmx_prompt;
        ```
      </method>
    </request_extensions>

    <template_helpers>
      <description>Helpers available in templates</description>

      <helper_group name="htmx">
        <helper name="htmx">
          Include htmx script tag:
          ```html
          &lt;%= htmx() %&gt;
          &lt;!-- &lt;script src="/static/htmx/htmx.min.js"&gt;&lt;/script&gt; --&gt;
          ```
        </helper>

        <helper name="htmx_ws">
          Include WebSocket extension:
          ```html
          &lt;%= htmx_ws() %&gt;
          ```
        </helper>

        <helper name="htmx_sse">
          Include SSE extension:
          ```html
          &lt;%= htmx_sse() %&gt;
          ```
        </helper>

        <helper name="hx_get">
          Generate hx-get and related attributes:
          ```perl
          hx_get($url, %options)

          # Options:
          #   target  =&gt; '#selector'     # hx-target
          #   swap    =&gt; 'innerHTML'     # hx-swap
          #   trigger =&gt; 'click'         # hx-trigger
          #   confirm =&gt; 'Are you sure?' # hx-confirm
          #   push_url =&gt; 1              # hx-push-url
          #   select  =&gt; '.selector'     # hx-select
          #   vals    =&gt; { key =&gt; 'val' } # hx-vals (JSON)
          #   headers =&gt; { X-Custom =&gt; 'val' } # hx-headers
          #   indicator =&gt; '#spinner'    # hx-indicator
          #   disabled_elt =&gt; 'this'     # hx-disabled-elt

          # Returns string of attributes
          ```
        </helper>

        <helper name="hx_post">hx_post($url, %options) - Same options as hx_get</helper>
        <helper name="hx_put">hx_put($url, %options) - Same options as hx_get</helper>
        <helper name="hx_patch">hx_patch($url, %options) - Same options as hx_get</helper>
        <helper name="hx_delete">hx_delete($url, %options) - Same options as hx_get</helper>

        <helper name="hx_sse">
          SSE connection attributes:
          ```perl
          hx_sse($url, %options)

          # Options:
          #   connect =&gt; 1               # hx-ext="sse" sse-connect="$url"
          #   swap    =&gt; 'innerHTML'     # sse-swap

          # Example:
          &lt;div &lt;%= hx_sse('/events', connect =&gt; 1, swap =&gt; 'beforeend') %&gt;&gt;
          ```
        </helper>

        <helper name="hx_ws">
          WebSocket connection attributes:
          ```perl
          hx_ws($url, %options)

          # Options:
          #   connect =&gt; 1               # hx-ext="ws" ws-connect="$url"
          #   send    =&gt; 'selector'      # ws-send
          ```
        </helper>
      </helper_group>

      <helper_group name="routes">
        <helper name="route">
          Generate URL from named route:
          ```perl
          route('route_name')
          route('route_name', id =&gt; 123)
          route('route_name', id =&gt; 123, query =&gt; { page =&gt; 2 })
          ```
        </helper>
      </helper_group>

      <helper_group name="rendering">
        <helper name="include">
          Include a partial template:
          ```perl
          include('path/to/_partial', var =&gt; $value)
          ```
        </helper>

        <helper name="extends">
          Extend a layout:
          ```perl
          extends('layouts/default', title =&gt; 'Page Title')
          ```
        </helper>

        <helper name="block">
          Define a content block:
          ```perl
          block 'content' =&gt; begin
            &lt;h1&gt;Content here&lt;/h1&gt;
          end
          ```
        </helper>

        <helper name="content">
          Output the content block in layouts:
          ```html
          &lt;%= content %&gt;
          ```
        </helper>

        <helper name="content_for">
          Define named content blocks:
          ```perl
          content_for 'scripts' =&gt; begin
            &lt;script src="extra.js"&gt;&lt;/script&gt;
          end
          ```
        </helper>
      </helper_group>

      <helper_group name="html">
        <helper name="escape">
          HTML escape a string:
          ```perl
          escape($string)
          ```
        </helper>

        <helper name="raw">
          Output unescaped HTML:
          ```perl
          raw($html_string)
          ```
        </helper>

        <helper name="safe">
          Mark string as safe (already escaped):
          ```perl
          safe($string)
          ```
        </helper>
      </helper_group>

      <helper_group name="valiant" role="PAGI::Simple::View::Role::Valiant">
        <helper name="form_for">
          Create form bound to model:
          ```perl
          form_for($model, \%options, sub ($fb) { ... })
          ```
        </helper>

        <helper name="form_tag">
          Create form without model binding:
          ```perl
          form_tag(\%options, sub { ... })
          ```
        </helper>

        <formbuilder_methods>
          Methods available on $fb in form_for block:

          # Input fields
          $fb-&gt;input($attr, %opts)           # text input
          $fb-&gt;password($attr, %opts)        # password input
          $fb-&gt;hidden($attr, %opts)          # hidden input
          $fb-&gt;text_area($attr, %opts)       # textarea
          $fb-&gt;checkbox($attr, $checked, $unchecked)
          $fb-&gt;radio_button($attr, $value)
          $fb-&gt;select($attr, $options, %opts)
          $fb-&gt;collection_select($attr, $collection, $value_method, $label_method)
          $fb-&gt;date_field($attr, %opts)
          $fb-&gt;datetime_local_field($attr, %opts)
          $fb-&gt;time_field($attr, %opts)

          # Labels and errors
          $fb-&gt;label($attr, %opts, $content)
          $fb-&gt;errors_for($attr, sub ($errors) { ... })
          $fb-&gt;model_errors(sub ($errors) { ... })
          $fb-&gt;attribute_has_errors($attr)  # boolean
          $fb-&gt;form_has_errors              # boolean

          # Nested forms
          $fb-&gt;fields_for($relation, sub ($nested_fb, $item) { ... })
          $fb-&gt;fields_for($relation, \%opts, sub ($fb, $item) { ... }, sub ($new_fb) { ... })

          # Buttons
          $fb-&gt;submit($text, %opts)
          $fb-&gt;button($attr, %opts, $content)

          # Utilities
          $fb-&gt;emit_hidden_ids              # hidden id fields for updates
          $fb-&gt;tag_id_for_attribute($attr)  # generated id
          $fb-&gt;tag_name_for_attribute($attr) # generated name
        </formbuilder_methods>
      </helper_group>
    </template_helpers>

    <model_base_class>
      <description>PAGI::Simple::Model base class API</description>

      <method name="new">
        Default constructor:
        ```perl
        sub new ($class, %args) {
            bless \%args, $class;
        }
        ```
      </method>

      <method name="for_context">
        Factory method called by $c-&gt;model():
        ```perl
        sub for_context ($class, $c, $config) {
            return $class-&gt;new(%$config, c =&gt; $c);
        }
        ```
        Override for custom instantiation. Can be async:
        ```perl
        async sub for_context ($class, $c, $config) {
            my $db = await $c-&gt;model('DB');
            return $class-&gt;new(%$config, c =&gt; $c, db =&gt; $db);
        }
        ```
      </method>

      <method name="c">
        Access the request context:
        ```perl
        sub c ($self) { $self-&gt;{c} }
        ```
      </method>
    </model_base_class>

    <per_request_role>
      <description>PAGI::Simple::Model::Role::PerRequest</description>

      <usage>
        ```perl
        package MyApp::Model::CurrentUser;
        use parent 'PAGI::Simple::Model';
        use Role::Tiny::With;
        with 'PAGI::Simple::Model::Role::PerRequest';
        ```
      </usage>

      <behavior>
        Wraps for_context to cache instance in $c-&gt;stash:
        ```perl
        around for_context =&gt; sub ($orig, $class, $c, $config) {
            my $key = "_model_cache_$class";
            return $c-&gt;stash-&gt;{$key} //= $class-&gt;$orig($c, $config);
        };
        ```
      </behavior>
    </per_request_role>
  </api_reference>

  <implementation_steps>
    <step number="1">
      <title>View Infrastructure and Basic Rendering</title>
      <target>Basic template rendering without htmx</target>
      <tasks>
        - Create PAGI::Simple::View class wrapping Template::EmbeddedPerl
        - Add views() configuration method to PAGI::Simple
        - Add render() method to PAGI::Simple::Context
        - Implement template discovery from configured directory
        - Implement template caching in memory
        - Create PAGI::Simple::View::Helpers base helper class
        - Implement escape(), raw(), safe() helpers
        - Implement include() helper for partials
        - Write t/view/00-view-basic.t
        - Write t/view/01-view-helpers.t
      </tasks>
      <acceptance_criteria>
        - Templates render with variable interpolation
        - Auto-escaping works by default
        - Partials can be included
        - Template caching improves performance
        - Development mode disables caching
      </acceptance_criteria>
    </step>

    <step number="2">
      <title>Layout System</title>
      <target>Layout inheritance with extends/block</target>
      <tasks>
        - Create PAGI::Simple::View::Layout module
        - Implement extends() helper
        - Implement block() helper with begin/end syntax
        - Implement content helper for layout templates
        - Implement content_for() for named blocks (scripts, styles)
        - Handle layout template discovery
        - Write t/view/03-view-layouts.t
      </tasks>
      <acceptance_criteria>
        - Templates can extend layouts
        - Multiple blocks can be defined
        - content_for accumulates across includes
        - Nested layouts work
        - Missing blocks use empty string
      </acceptance_criteria>
    </step>

    <step number="3">
      <title>htmx Integration - Helpers</title>
      <target>htmx attribute helpers</target>
      <tasks>
        - Create PAGI::Simple::View::Helpers::Htmx module
        - Bundle htmx 2.0.x JavaScript files in share/
        - Implement htmx(), htmx_ws(), htmx_sse() script helpers
        - Implement hx_get(), hx_post(), hx_put(), hx_patch(), hx_delete()
        - Implement hx_sse(), hx_ws() for extensions
        - Handle all htmx options (target, swap, trigger, confirm, etc.)
        - Write t/view/02-view-htmx.t
      </tasks>
      <acceptance_criteria>
        - All hx_* helpers generate correct attributes
        - htmx script tags point to bundled files
        - Complex options (hx-vals, hx-headers) serialize to JSON
        - Trigger options (delay, throttle, changed) work
      </acceptance_criteria>
    </step>

    <step number="4">
      <title>htmx Integration - Auto Fragment Detection</title>
      <target>Automatic fragment vs full page rendering</target>
      <tasks>
        - Add is_htmx() method to PAGI::Simple::Request
        - Add htmx_target(), htmx_trigger_name(), htmx_current_url() methods
        - Modify render() to detect HX-Request header
        - When htmx request, render block content without layout
        - Implement render_or_redirect() helper
        - Implement empty_or_redirect() helper
        - Implement hx_trigger() response header helper
        - Implement hx_redirect(), hx_refresh() helpers
        - Write t/view/06-view-auto-fragment.t
      </tasks>
      <acceptance_criteria>
        - htmx requests automatically get fragments
        - Browser requests get full page with layout
        - render_or_redirect works correctly for both
        - HX-Trigger headers set properly
        - Response helpers work correctly
      </acceptance_criteria>
    </step>

    <step number="5">
      <title>TO_HTML Protocol</title>
      <target>Objects render themselves</target>
      <tasks>
        - Define TO_HTML($self, $view) protocol
        - Modify template rendering to check for TO_HTML
        - When outputting object, call TO_HTML if present
        - Pass view context to TO_HTML for include() access
        - Document TO_HTML protocol
        - Write t/view/05-view-to-html.t
      </tasks>
      <acceptance_criteria>
        - Objects with TO_HTML render automatically in templates
        - TO_HTML receives view context
        - Can call include() from TO_HTML
        - Objects without TO_HTML stringify normally
        - TO_HTML output is properly escaped/marked safe
      </acceptance_criteria>
    </step>

    <step number="6">
      <title>Named Routes Helper</title>
      <target>URL generation in templates</target>
      <tasks>
        - Create PAGI::Simple::View::Helpers::Routes module
        - Integrate with existing PAGI::Simple router
        - Implement route() template helper
        - Handle path parameters substitution
        - Handle query parameters
        - Handle missing routes (warn in dev, empty in prod)
        - Write tests for route helper
      </tasks>
      <acceptance_criteria>
        - route('name', params) generates correct URLs
        - Path parameters substituted correctly
        - Query parameters appended correctly
        - Missing routes handled gracefully
        - Works in both templates and hx_* helpers
      </acceptance_criteria>
    </step>

    <step number="7">
      <title>Model Layer - Base Infrastructure</title>
      <target>Basic model class and context integration</target>
      <tasks>
        - Create PAGI::Simple::Model base class
        - Implement new(), for_context(), c() methods
        - Create PAGI::Simple::Models registry class
        - Add model_namespace configuration to PAGI::Simple
        - Add model_config configuration to PAGI::Simple
        - Add model() method to PAGI::Simple::Context
        - Implement basic model instantiation (no discovery)
        - Write t/model/00-model-basic.t
      </tasks>
      <acceptance_criteria>
        - Models can be manually registered
        - $c-&gt;model('Name') returns instance
        - for_context receives context and config
        - Model has access to $c via accessor
      </acceptance_criteria>
    </step>

    <step number="8">
      <title>Model Layer - Auto Discovery</title>
      <target>Module::Pluggable-based model discovery</target>
      <tasks>
        - Integrate Module::Pluggable into PAGI::Simple::Models
        - Discover all modules under model_namespace
        - Handle nested namespaces (Foo::Bar -&gt; 'Foo::Bar')
        - Lazy-load model classes on first access
        - Clear error messages for missing models
        - Handle model compilation errors gracefully
        - Write t/model/01-model-discovery.t
      </tasks>
      <acceptance_criteria>
        - Models auto-discovered from namespace
        - Nested models accessible by qualified name
        - Missing model gives clear error
        - Compilation errors reported helpfully
        - Discovery happens once at startup
      </acceptance_criteria>
    </step>

    <step number="9">
      <title>Model Layer - Factory and Caching</title>
      <target>Factory pattern and per-request caching</target>
      <tasks>
        - Ensure factory pattern (fresh instance each call) is default
        - Create PAGI::Simple::Model::Role::PerRequest role
        - Implement around for_context for caching
        - Cache in $c-&gt;stash with unique key per model class
        - Document factory vs cached patterns
        - Write t/model/02-model-factory.t
        - Write t/model/03-model-per-request.t
      </tasks>
      <acceptance_criteria>
        - Default: each $c-&gt;model() call returns new instance
        - With PerRequest role: same instance within request
        - Different requests get different instances
        - Cache key handles inheritance correctly
      </acceptance_criteria>
    </step>

    <step number="10">
      <title>Model Layer - Async Support</title>
      <target>Async model methods and for_context</target>
      <tasks>
        - Modify $c-&gt;model() to detect async for_context
        - Return Future from model() when for_context is async
        - Handle await $c-&gt;model('Name') pattern
        - Ensure sync models still work with plain $c-&gt;model()
        - Test async model chains
        - Write t/model/04-model-async.t
      </tasks>
      <acceptance_criteria>
        - Sync for_context works with $c-&gt;model()
        - Async for_context works with await $c-&gt;model()
        - Mixed sync/async models work together
        - Per-request caching works with async
      </acceptance_criteria>
    </step>

    <step number="11">
      <title>Valiant Integration - Role Setup</title>
      <target>Isolated Valiant role infrastructure</target>
      <tasks>
        - Create PAGI::Simple::View::Role::Valiant module
        - Check for Valiant availability at runtime
        - Proxy methods from Valiant::HTML::Util::Form
        - Proxy methods from Valiant::HTML::Util::FormTags
        - Make role composable via view configuration
        - Graceful degradation if Valiant not installed
        - Write t/valiant/00-valiant-form-for.t
      </tasks>
      <acceptance_criteria>
        - Role composes cleanly into view
        - All form helpers available in templates
        - Works without Valiant installed (skip or basic fallback)
        - Clear error if Valiant method used without Valiant
      </acceptance_criteria>
    </step>

    <step number="12">
      <title>Valiant Integration - form_for and Inputs</title>
      <target>Full form_for functionality</target>
      <tasks>
        - Implement form_for($model, \%opts, $block) helper
        - Pass FormBuilder to block callback
        - Implement all input helpers on FormBuilder
        - Handle htmx attributes in form options
        - Auto-populate values from model
        - Generate proper name/id attributes
        - Write t/valiant/02-valiant-inputs.t
      </tasks>
      <acceptance_criteria>
        - form_for creates bound form
        - Input values populated from model
        - Names follow model.attribute convention
        - IDs follow model_attribute convention
        - htmx attributes work on form and inputs
      </acceptance_criteria>
    </step>

    <step number="13">
      <title>Valiant Integration - Error Display</title>
      <target>Validation error display helpers</target>
      <tasks>
        - Implement errors_for($attr, $block) helper
        - Implement model_errors($block) helper
        - Implement attribute_has_errors($attr) helper
        - Implement form_has_errors helper
        - Support custom error rendering via block
        - Default error rendering as span.error
        - Write t/valiant/03-valiant-errors.t
      </tasks>
      <acceptance_criteria>
        - Field errors display next to inputs
        - Model errors display at top of form
        - Custom error templates work
        - attribute_has_errors returns boolean
        - CSS class can be applied conditionally
      </acceptance_criteria>
    </step>

    <step number="14">
      <title>Valiant Integration - fields_for and Nested Forms</title>
      <target>Nested form support for relationships</target>
      <tasks>
        - Implement fields_for($relation, $block) helper
        - Handle has_many collections with indexing
        - Handle belongs_to/has_one single relations
        - Support _destroy checkbox for deletion
        - Support new item block for adding to collection
        - Proper name generation for nested attributes
        - Write t/valiant/01-valiant-fields-for.t
      </tasks>
      <acceptance_criteria>
        - Nested forms render for relationships
        - Collection items indexed properly
        - _destroy marks items for deletion
        - New item block adds empty form
        - Names nest correctly (model.relation[0].attr)
      </acceptance_criteria>
    </step>

    <step number="15">
      <title>Valiant Integration - htmx Patterns</title>
      <target>htmx + Valiant integration patterns</target>
      <tasks>
        - Document inline validation pattern
        - Create validation endpoint helper/pattern
        - Test form submission with htmx
        - Test error display after htmx submission
        - Test inline field validation
        - Document common htmx + Valiant patterns
        - Write t/valiant/05-valiant-htmx.t
      </tasks>
      <acceptance_criteria>
        - Forms submit via htmx correctly
        - Errors display after htmx submission
        - Inline validation works on blur
        - Form re-renders with errors preserve values
        - Successful submission triggers appropriate response
      </acceptance_criteria>
    </step>

    <step number="16">
      <title>Example Application - Todo App</title>
      <target>Complete todo application example</target>
      <tasks>
        - Create examples/view-todo/ directory
        - Implement app.pl with all routes
        - Create MyApp::Model::Todo model
        - Create MyApp::Entity::Todo with Valiant validations
        - Create all templates (layouts, index, partials)
        - Implement CRUD operations
        - Implement htmx interactions (add, toggle, delete, edit)
        - Implement inline editing
        - Implement SSE for live updates
        - Write comprehensive README.md
        - Write t/integration/00-todo-app.t
      </tasks>
      <acceptance_criteria>
        - Full CRUD functionality works
        - htmx partial updates work
        - Inline editing with validation works
        - SSE updates across tabs work
        - Progressive enhancement (works without JS)
        - Test coverage for all features
      </acceptance_criteria>
    </step>

    <step number="17">
      <title>Example Application - User Management</title>
      <target>More complex example with authentication patterns</target>
      <tasks>
        - Create examples/view-users/ directory
        - Implement user model with validation
        - Implement user entity with password handling
        - Create user list, show, edit, new templates
        - Implement form with multiple field types
        - Implement select, checkbox, radio inputs
        - Show per-request cached CurrentUser model
        - Document authentication patterns (no actual auth)
        - Write t/integration/01-user-crud.t
      </tasks>
      <acceptance_criteria>
        - All input types demonstrated
        - Complex validation rules shown
        - Per-request model caching demonstrated
        - Form patterns well-documented
        - Tests pass
      </acceptance_criteria>
    </step>

    <step number="18">
      <title>Example Application - Nested Forms</title>
      <target>Complex nested form example</target>
      <tasks>
        - Create examples/view-nested/ directory
        - Implement Task model with Comments relationship
        - Implement nested form with fields_for
        - Show adding new items to collection
        - Show removing items with _destroy
        - Show validation errors on nested items
        - Document nested form patterns
        - Write t/integration/02-nested-forms.t
      </tasks>
      <acceptance_criteria>
        - Nested forms render correctly
        - Adding items works via htmx
        - Removing items works via htmx
        - Validation errors show on nested items
        - Form state preserved across submissions
        - Tests pass
      </acceptance_criteria>
    </step>

    <step number="19">
      <title>Development Mode and Error Handling</title>
      <target>Developer experience improvements</target>
      <tasks>
        - Implement development mode flag
        - Disable template caching in development
        - Show detailed errors with template source
        - Show line numbers in template errors
        - Implement template auto-reload on change
        - Better error messages for missing templates
        - Better error messages for missing helpers
        - Better error messages for missing routes
      </tasks>
      <acceptance_criteria>
        - Development mode shows helpful errors
        - Template source shown in errors
        - Line numbers accurate in error messages
        - Templates reload without server restart
        - Production mode hides details
      </acceptance_criteria>
    </step>

    <step number="20">
      <title>Documentation and Polish</title>
      <target>Complete documentation</target>
      <tasks>
        - Write POD for PAGI::Simple::View
        - Write POD for PAGI::Simple::Model
        - Write POD for PAGI::Simple::View::Role::Valiant
        - Write POD for all helper modules
        - Write comprehensive SYNOPSIS for each module
        - Create docs/view-layer.mkdn guide
        - Create docs/model-layer.mkdn guide
        - Create docs/htmx-patterns.mkdn guide
        - Create docs/valiant-forms.mkdn guide
        - Review and update CLAUDE.md
        - Ensure all tests pass
      </tasks>
      <acceptance_criteria>
        - All public APIs documented
        - SYNOPSIS examples are runnable
        - Guides cover common patterns
        - Test suite passes
        - Examples run correctly
      </acceptance_criteria>
    </step>
  </implementation_steps>

  <file_specifications>
    <file path="lib/PAGI/Simple/View.pm">
      <description>Main view class wrapping Template::EmbeddedPerl</description>
      <responsibilities>
        - Template compilation and caching
        - Template rendering with variables
        - Helper registration and invocation
        - Layout system coordination
        - TO_HTML protocol handling
        - htmx fragment detection
      </responsibilities>
      <interface>
        ```perl
        package PAGI::Simple::View;
        use Moo;
        use Template::EmbeddedPerl;

        has 'template_dir' =&gt; (is =&gt; 'ro', required =&gt; 1);
        has 'extension' =&gt; (is =&gt; 'ro', default =&gt; '.html.ep');
        has 'auto_escape' =&gt; (is =&gt; 'ro', default =&gt; 1);
        has 'cache' =&gt; (is =&gt; 'ro', default =&gt; 1);
        has 'development' =&gt; (is =&gt; 'ro', default =&gt; 0);
        has 'helpers' =&gt; (is =&gt; 'ro', default =&gt; sub { {} });

        sub render ($self, $template_name, %vars);
        sub render_string ($self, $template_name, %vars);
        sub render_fragment ($self, $template_name, %vars);
        sub include ($self, $partial_name, %vars);
        sub compile_template ($self, $template_name);
        sub clear_cache ($self);
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/View/Layout.pm">
      <description>Layout system with extends/block inheritance</description>
      <interface>
        ```perl
        package PAGI::Simple::View::Layout;

        sub process_extends ($view, $layout_name, %vars, $content_block);
        sub define_block ($view, $block_name, $content);
        sub get_block ($view, $block_name);
        sub content_for ($view, $name, $content);
        sub yield_content_for ($view, $name);
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/View/Helpers.pm">
      <description>Base helper class and core helpers</description>
      <interface>
        ```perl
        package PAGI::Simple::View::Helpers;

        sub escape ($text);
        sub raw ($html);
        sub safe ($text);
        sub include ($partial, %vars);
        sub extends ($layout, %vars);
        sub block ($name, $content);
        sub content ();
        sub content_for ($name, $content);
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/View/Helpers/Htmx.pm">
      <description>htmx attribute helpers</description>
      <interface>
        ```perl
        package PAGI::Simple::View::Helpers::Htmx;

        sub htmx ();                              # script tag
        sub htmx_ws ();                           # ws extension
        sub htmx_sse ();                          # sse extension
        sub hx_get ($url, %opts);
        sub hx_post ($url, %opts);
        sub hx_put ($url, %opts);
        sub hx_patch ($url, %opts);
        sub hx_delete ($url, %opts);
        sub hx_sse ($url, %opts);
        sub hx_ws ($url, %opts);
        sub _build_hx_attrs ($method, $url, %opts);
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/View/Helpers/Routes.pm">
      <description>Named route URL generation helper</description>
      <interface>
        ```perl
        package PAGI::Simple::View::Helpers::Routes;

        sub route ($name, %params);
        sub _substitute_params ($pattern, %params);
        sub _build_query_string (%params);
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/View/Role/Valiant.pm">
      <description>Valiant form builder integration (isolated role)</description>
      <interface>
        ```perl
        package PAGI::Simple::View::Role::Valiant;
        use Role::Tiny;

        requires 'render_string';

        sub form_for ($self, $model, $opts, $block);
        sub form_tag ($self, $opts, $block);
        sub fields_for ($self, $fb, $relation, $opts, $block, $new_block);

        # Proxied from Valiant::HTML::Util::FormTags
        sub label_tag ($self, @args);
        sub text_field_tag ($self, @args);
        sub password_field_tag ($self, @args);
        sub hidden_field_tag ($self, @args);
        sub submit_tag ($self, @args);
        # ... etc
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/Model.pm">
      <description>Base model class</description>
      <interface>
        ```perl
        package PAGI::Simple::Model;
        use experimental 'signatures';

        sub new ($class, %args) {
            bless \%args, $class;
        }

        sub for_context ($class, $c, $config) {
            return $class-&gt;new(%$config, c =&gt; $c);
        }

        sub c ($self) { $self-&gt;{c} }
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/Model/Role/PerRequest.pm">
      <description>Per-request caching role for models</description>
      <interface>
        ```perl
        package PAGI::Simple::Model::Role::PerRequest;
        use Role::Tiny;

        around for_context =&gt; sub ($orig, $class, $c, $config) {
            my $key = "_model_cache_$class";
            return $c-&gt;stash-&gt;{$key} //= $class-&gt;$orig($c, $config);
        };
        ```
      </interface>
    </file>

    <file path="lib/PAGI/Simple/Models.pm">
      <description>Model registry and discovery</description>
      <interface>
        ```perl
        package PAGI::Simple::Models;
        use Module::Pluggable;

        has 'namespace' =&gt; (is =&gt; 'ro', required =&gt; 1);
        has 'config' =&gt; (is =&gt; 'ro', default =&gt; sub { {} });
        has 'registry' =&gt; (is =&gt; 'lazy');

        sub _build_registry ($self);
        sub discover ($self);
        sub get ($self, $name, $c);
        sub has_model ($self, $name);
        sub list_models ($self);
        ```
      </interface>
    </file>
  </file_specifications>

  <example_application>
    <name>Todo Application</name>
    <location>examples/view-todo/</location>
    <structure>
      examples/view-todo/
        app.pl                    # Main application
        lib/
          MyApp/
            Entity/
              Todo.pm             # Todo entity with Valiant validations
            Model/
              Todo.pm             # Todo model (in-memory storage)
              Stats.pm            # Per-request cached stats model
        templates/
          layouts/
            default.html.ep       # Main layout with htmx
          index.html.ep           # Main page
          todos/
            _list.html.ep         # Todo list partial
            _item.html.ep         # Single todo item
            _form.html.ep         # New todo form
            _edit_form.html.ep    # Edit todo form
            _footer.html.ep       # Footer with counts and filters
        static/
          htmx/
            htmx.min.js           # Bundled htmx
            ext/
              sse.js              # SSE extension
        README.md                 # Documentation
    </structure>

    <app_pl>
      ```perl
      #!/usr/bin/env perl
      use strict;
      use warnings;
      use experimental 'signatures';
      use lib 'lib';
      use PAGI::Simple;

      my $app = PAGI::Simple-&gt;new(
          name            =&gt; 'Todo App',
          model_namespace =&gt; 'MyApp::Model',
      );

      $app-&gt;views('./templates', {
          auto_escape =&gt; 1,
          development =&gt; $ENV{PAGI_DEV} // 0,
          roles       =&gt; ['PAGI::Simple::View::Role::Valiant'],
          helpers     =&gt; {
              pluralize =&gt; sub ($n, $word) { $n == 1 ? $word : "${word}s" },
          },
      });

      $app-&gt;static('/static' =&gt; './static');

      #-----------------------------------------------------------------------
      # Routes
      #-----------------------------------------------------------------------

      $app-&gt;get('/' =&gt; sub ($c) {
          my $todos = $c-&gt;model('Todo');
          my $new_todo = MyApp::Entity::Todo-&gt;new;

          $c-&gt;render('index',
              todos    =&gt; [$todos-&gt;all],
              new_todo =&gt; $new_todo,
              active   =&gt; $todos-&gt;active_count,
              filter   =&gt; 'all',
          );
      })-&gt;name('home');

      $app-&gt;get('/active' =&gt; sub ($c) {
          my $todos = $c-&gt;model('Todo');
          $c-&gt;render('index',
              todos    =&gt; [$todos-&gt;active],
              new_todo =&gt; MyApp::Entity::Todo-&gt;new,
              active   =&gt; $todos-&gt;active_count,
              filter   =&gt; 'active',
          );
      })-&gt;name('active');

      $app-&gt;get('/completed' =&gt; sub ($c) {
          my $todos = $c-&gt;model('Todo');
          $c-&gt;render('index',
              todos    =&gt; [$todos-&gt;completed],
              new_todo =&gt; MyApp::Entity::Todo-&gt;new,
              active   =&gt; $todos-&gt;active_count,
              filter   =&gt; 'completed',
          );
      })-&gt;name('completed');

      $app-&gt;post('/todos' =&gt; async sub ($c) {
          my $params = await $c-&gt;req-&gt;body_params;
          my $todos = $c-&gt;model('Todo');

          my $todo = MyApp::Entity::Todo-&gt;new(
              title =&gt; $params-&gt;get('todo.title') // '',
          );

          if ($todo-&gt;validate-&gt;valid) {
              $todos-&gt;save($todo);
              $c-&gt;hx_trigger('todoAdded');
              $c-&gt;render_or_redirect('/', 'todos/_item',
                  todo   =&gt; $todo,
                  active =&gt; $todos-&gt;active_count,
              );
          } else {
              $c-&gt;render('todos/_form', todo =&gt; $todo);
          }
      })-&gt;name('todos_create');

      $app-&gt;patch('/todos/:id/toggle' =&gt; sub ($c) {
          my $todos = $c-&gt;model('Todo');
          my $todo = $todos-&gt;toggle($c-&gt;path_params-&gt;{id});

          return $c-&gt;status(404)-&gt;text('Not found') unless $todo;

          $c-&gt;hx_trigger('todoChanged');
          $c-&gt;render('todos/_item',
              todo   =&gt; $todo,
              active =&gt; $todos-&gt;active_count,
          );
      })-&gt;name('todo_toggle');

      $app-&gt;get('/todos/:id/edit' =&gt; sub ($c) {
          my $todo = $c-&gt;model('Todo')-&gt;find($c-&gt;path_params-&gt;{id});
          return $c-&gt;status(404)-&gt;text('Not found') unless $todo;

          $c-&gt;render('todos/_edit_form', todo =&gt; $todo);
      })-&gt;name('todo_edit');

      $app-&gt;patch('/todos/:id' =&gt; async sub ($c) {
          my $params = await $c-&gt;req-&gt;body_params;
          my $todos = $c-&gt;model('Todo');
          my $todo = $todos-&gt;find($c-&gt;path_params-&gt;{id});

          return $c-&gt;status(404)-&gt;text('Not found') unless $todo;

          $todo-&gt;title($params-&gt;get('todo.title') // '');

          if ($todo-&gt;validate-&gt;valid) {
              $todos-&gt;save($todo);
              $c-&gt;render('todos/_item',
                  todo   =&gt; $todo,
                  active =&gt; $todos-&gt;active_count,
              );
          } else {
              $c-&gt;render('todos/_edit_form', todo =&gt; $todo);
          }
      })-&gt;name('todo_update');

      $app-&gt;del('/todos/:id' =&gt; sub ($c) {
          $c-&gt;model('Todo')-&gt;delete($c-&gt;path_params-&gt;{id});
          $c-&gt;hx_trigger('todoDeleted');
          $c-&gt;empty_or_redirect('/');
      })-&gt;name('todo_delete');

      $app-&gt;post('/todos/clear-completed' =&gt; sub ($c) {
          my $todos = $c-&gt;model('Todo');
          $todos-&gt;clear_completed;

          $c-&gt;render_or_redirect('/', 'todos/_list',
              todos  =&gt; [$todos-&gt;all],
              active =&gt; $todos-&gt;active_count,
              filter =&gt; 'all',
          );
      })-&gt;name('todos_clear');

      $app-&gt;post('/todos/toggle-all' =&gt; sub ($c) {
          my $todos = $c-&gt;model('Todo');
          $todos-&gt;toggle_all;

          $c-&gt;render_or_redirect('/', 'todos/_list',
              todos  =&gt; [$todos-&gt;all],
              active =&gt; $todos-&gt;active_count,
              filter =&gt; 'all',
          );
      })-&gt;name('todos_toggle_all');

      # Inline field validation
      $app-&gt;post('/validate/todo/:field' =&gt; async sub ($c) {
          my $field = $c-&gt;path_params-&gt;{field};
          my $params = await $c-&gt;req-&gt;body_params;

          my $todo = MyApp::Entity::Todo-&gt;new;
          $todo-&gt;$field($params-&gt;get("todo.$field") // '');
          $todo-&gt;validate;

          if ($todo-&gt;errors-&gt;has_error($field)) {
              my @msgs = $todo-&gt;errors-&gt;messages_for($field);
              $c-&gt;html(qq{&lt;span class="error"&gt;@msgs&lt;/span&gt;});
          } else {
              $c-&gt;html(qq{&lt;span class="error"&gt;&lt;/span&gt;});
          }
      })-&gt;name('validate_field');

      # SSE for live updates
      $app-&gt;sse('/todos/live' =&gt; sub ($sse) {
          $sse-&gt;subscribe('todos:changes');
          $sse-&gt;send_event(event =&gt; 'connected', data =&gt; 'ok');

          $sse-&gt;on(pubsub =&gt; sub ($channel, $data) {
              $sse-&gt;send_event(event =&gt; 'refresh', data =&gt; $data-&gt;{action});
          });
      });

      $app-&gt;to_app;
      ```
    </app_pl>

    <entity_todo>
      ```perl
      # lib/MyApp/Entity/Todo.pm
      package MyApp::Entity::Todo;
      use Moo;
      use Valiant::Validations;
      use experimental 'signatures';

      has 'id'        =&gt; (is =&gt; 'rw');
      has 'title'     =&gt; (is =&gt; 'rw', default =&gt; '');
      has 'completed' =&gt; (is =&gt; 'rw', default =&gt; 0);

      validates title =&gt; (
          presence =&gt; 1,
          length   =&gt; { minimum =&gt; 2, maximum =&gt; 100 },
      );

      sub TO_HTML ($self, $view) {
          $view-&gt;include('todos/_item', todo =&gt; $self);
      }

      1;
      ```
    </entity_todo>

    <model_todo>
      ```perl
      # lib/MyApp/Model/Todo.pm
      package MyApp::Model::Todo;
      use parent 'PAGI::Simple::Model';
      use experimental 'signatures';
      use MyApp::Entity::Todo;

      # Class-level in-memory storage
      my $next_id = 1;
      my %storage;

      # Seed data
      _seed() unless %storage;

      sub _seed {
          _store({ id =&gt; $next_id++, title =&gt; 'Learn PAGI::Simple', completed =&gt; 0 });
          _store({ id =&gt; $next_id++, title =&gt; 'Build with htmx', completed =&gt; 0 });
          _store({ id =&gt; $next_id++, title =&gt; 'Deploy app', completed =&gt; 1 });
      }

      sub _store ($data) {
          $storage{$data-&gt;{id}} = $data;
      }

      sub all ($self) {
          map { MyApp::Entity::Todo-&gt;new(%$_) }
          sort { $a-&gt;{id} &lt;=&gt; $b-&gt;{id} }
          values %storage;
      }

      sub active ($self) {
          grep { !$_-&gt;completed } $self-&gt;all;
      }

      sub completed ($self) {
          grep { $_-&gt;completed } $self-&gt;all;
      }

      sub find ($self, $id) {
          my $data = $storage{$id} or return undef;
          return MyApp::Entity::Todo-&gt;new(%$data);
      }

      sub active_count ($self) {
          scalar grep { !$_-&gt;{completed} } values %storage;
      }

      sub save ($self, $todo) {
          unless ($todo-&gt;id) {
              $todo-&gt;id($next_id++);
          }
          $storage{$todo-&gt;id} = {
              id        =&gt; $todo-&gt;id,
              title     =&gt; $todo-&gt;title,
              completed =&gt; $todo-&gt;completed,
          };
          $self-&gt;_publish('save', $todo);
          return $todo;
      }

      sub toggle ($self, $id) {
          my $data = $storage{$id} or return undef;
          $data-&gt;{completed} = !$data-&gt;{completed};
          $self-&gt;_publish('toggle', $data);
          return MyApp::Entity::Todo-&gt;new(%$data);
      }

      sub delete ($self, $id) {
          my $data = delete $storage{$id} or return;
          $self-&gt;_publish('delete', { id =&gt; $id });
          return 1;
      }

      sub clear_completed ($self) {
          for my $id (keys %storage) {
              delete $storage{$id} if $storage{$id}{completed};
          }
          $self-&gt;_publish('clear', {});
      }

      sub toggle_all ($self) {
          my $all_done = !grep { !$_-&gt;{completed} } values %storage;
          $_-&gt;{completed} = !$all_done for values %storage;
          $self-&gt;_publish('toggle_all', {});
      }

      sub _publish ($self, $action, $data) {
          if (my $app = $self-&gt;c &amp;&amp; $self-&gt;c-&gt;app) {
              $app-&gt;publish('todos:changes', { action =&gt; $action, %$data });
          }
      }

      1;
      ```
    </model_todo>

    <template_layout>
      ```html
      &lt;!-- templates/layouts/default.html.ep --&gt;
      &lt;!DOCTYPE html&gt;
      &lt;html lang="en"&gt;
      &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
        &lt;title&gt;&lt;%= $title // 'Todo App' %&gt;&lt;/title&gt;
        &lt;%= htmx() %&gt;
        &lt;%= htmx_sse() %&gt;
        &lt;style&gt;
          * { box-sizing: border-box; }
          body {
            font-family: system-ui, sans-serif;
            max-width: 500px;
            margin: 2rem auto;
            padding: 0 1rem;
            background: #f5f5f5;
          }
          .todoapp {
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
          }
          h1 {
            text-align: center;
            color: #b83f45;
            font-size: 4rem;
            font-weight: 100;
            margin: 0;
            padding: 1rem;
          }
          .new-todo {
            width: 100%;
            padding: 1rem;
            font-size: 1.2rem;
            border: none;
            border-bottom: 1px solid #eee;
          }
          .todo-list { list-style: none; padding: 0; margin: 0; }
          .todo-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            gap: 0.75rem;
          }
          .todo-item.completed label {
            text-decoration: line-through;
            color: #aaa;
          }
          .todo-item input[type="checkbox"] {
            width: 1.5rem;
            height: 1.5rem;
          }
          .todo-item label { flex: 1; cursor: pointer; }
          .todo-item .destroy {
            opacity: 0;
            background: none;
            border: none;
            color: #cc9a9a;
            font-size: 1.5rem;
            cursor: pointer;
          }
          .todo-item:hover .destroy { opacity: 1; }
          .footer {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            color: #777;
            font-size: 0.875rem;
          }
          .filters { display: flex; gap: 0.5rem; }
          .filters a {
            padding: 0.25rem 0.5rem;
            border: 1px solid transparent;
            border-radius: 4px;
            text-decoration: none;
            color: inherit;
          }
          .filters a.selected { border-color: #b83f45; }
          .field.has-error input { border-color: #cc0000; }
          .error { color: #cc0000; font-size: 0.875rem; }
          .htmx-request { opacity: 0.5; }
        &lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;%= content %&gt;
      &lt;/body&gt;
      &lt;/html&gt;
      ```
    </template_layout>

    <template_index>
      ```html
      &lt;!-- templates/index.html.ep --&gt;
      &lt;% extends 'layouts/default', title =&gt; 'Todo App' %&gt;

      &lt;% block content =&gt; begin %&gt;
      &lt;section class="todoapp"
               &lt;%= hx_sse('/todos/live', connect =&gt; 1) %&gt;
               hx-trigger="sse:refresh"
               &lt;%= hx_get(route($filter), target =&gt; '.todoapp', select =&gt; '.todoapp', swap =&gt; 'outerHTML') %&gt;&gt;

        &lt;header&gt;
          &lt;h1&gt;todos&lt;/h1&gt;
          &lt;%= include 'todos/_form', todo =&gt; $new_todo %&gt;
        &lt;/header&gt;

        &lt;%= include 'todos/_list',
            todos  =&gt; $todos,
            active =&gt; $active,
            filter =&gt; $filter %&gt;
      &lt;/section&gt;
      &lt;% end %&gt;
      ```
    </template_index>

    <template_form>
      ```html
      &lt;!-- templates/todos/_form.html.ep --&gt;
      &lt;%= form_for $todo, {
          action =&gt; route('todos_create'),
          id     =&gt; 'new-todo-form',
          %{ hx_post(route('todos_create'),
                     target =&gt; '#new-todo-form',
                     swap   =&gt; 'outerHTML') }
      }, sub ($fb) { %&gt;

        &lt;div class="field &lt;%= $fb-&gt;attribute_has_errors('title') ? 'has-error' : '' %&gt;"&gt;
          &lt;%= $fb-&gt;input('title',
              class       =&gt; 'new-todo',
              placeholder =&gt; 'What needs to be done?',
              autofocus   =&gt; 1,
              %{ hx_post(route('validate_field', field =&gt; 'title'),
                         trigger =&gt; 'blur changed delay:300ms',
                         target  =&gt; 'next .error') }
          ) %&gt;
          &lt;%= $fb-&gt;errors_for('title', sub ($errs) { %&gt;
            &lt;span class="error"&gt;&lt;%= join ', ', @$errs %&gt;&lt;/span&gt;
          &lt;% }) %&gt;
        &lt;/div&gt;

      &lt;% } %&gt;
      ```
    </template_form>

    <template_item>
      ```html
      &lt;!-- templates/todos/_item.html.ep --&gt;
      &lt;li class="todo-item &lt;%= $todo-&gt;completed ? 'completed' : '' %&gt;"
          id="todo-&lt;%= $todo-&gt;id %&gt;"&gt;

        &lt;input type="checkbox"
               &lt;%= $todo-&gt;completed ? 'checked' : '' %&gt;
               &lt;%= hx_patch(route('todo_toggle', id =&gt; $todo-&gt;id),
                            target =&gt; "#todo-" . $todo-&gt;id,
                            swap   =&gt; 'outerHTML') %&gt;&gt;

        &lt;label &lt;%= hx_get(route('todo_edit', id =&gt; $todo-&gt;id),
                          trigger =&gt; 'dblclick',
                          target  =&gt; "#todo-" . $todo-&gt;id,
                          swap    =&gt; 'outerHTML') %&gt;&gt;
          &lt;%= $todo-&gt;title %&gt;
        &lt;/label&gt;

        &lt;button class="destroy"
                &lt;%= hx_delete(route('todo_delete', id =&gt; $todo-&gt;id),
                              target  =&gt; "#todo-" . $todo-&gt;id,
                              swap    =&gt; 'outerHTML',
                              confirm =&gt; 'Delete this todo?') %&gt;&gt;
          
        &lt;/button&gt;
      &lt;/li&gt;
      ```
    </template_item>

    <template_edit_form>
      ```html
      &lt;!-- templates/todos/_edit_form.html.ep --&gt;
      &lt;li class="todo-item editing" id="todo-&lt;%= $todo-&gt;id %&gt;"&gt;
        &lt;%= form_for $todo, {
            action =&gt; route('todo_update', id =&gt; $todo-&gt;id),
            method =&gt; 'PATCH',
            style  =&gt; 'display: contents',
            %{ hx_patch(route('todo_update', id =&gt; $todo-&gt;id),
                        target =&gt; "#todo-" . $todo-&gt;id,
                        swap   =&gt; 'outerHTML') }
        }, sub ($fb) { %&gt;

          &lt;input type="checkbox" disabled
                 &lt;%= $todo-&gt;completed ? 'checked' : '' %&gt;&gt;

          &lt;%= $fb-&gt;input('title',
              class     =&gt; 'edit-input',
              autofocus =&gt; 1,
              'hx-on:blur' =&gt; 'this.form.requestSubmit()',
              'hx-on:keydown' =&gt; "if(event.key==='Escape') htmx.ajax('PATCH','" .
                                 route('todo_update', id =&gt; $todo-&gt;id) .
                                 "','#todo-" . $todo-&gt;id . "')"
          ) %&gt;

          &lt;%= $fb-&gt;errors_for('title', sub ($errs) { %&gt;
            &lt;span class="error"&gt;&lt;%= join ', ', @$errs %&gt;&lt;/span&gt;
          &lt;% }) %&gt;

        &lt;% } %&gt;
      &lt;/li&gt;
      ```
    </template_edit_form>

    <template_list>
      ```html
      &lt;!-- templates/todos/_list.html.ep --&gt;
      &lt;main&gt;
        &lt;% if (@$todos) { %&gt;
          &lt;div class="toggle-all-container"&gt;
            &lt;label&gt;
              &lt;input type="checkbox"
                     &lt;%= $active == 0 ? 'checked' : '' %&gt;
                     &lt;%= hx_post(route('todos_toggle_all'),
                                 target =&gt; 'closest main',
                                 swap   =&gt; 'outerHTML') %&gt;&gt;
              Mark all as complete
            &lt;/label&gt;
          &lt;/div&gt;
        &lt;% } %&gt;

        &lt;ul class="todo-list"&gt;
          &lt;% for my $todo (@$todos) { %&gt;
            &lt;%= $todo %&gt;
          &lt;% } %&gt;
        &lt;/ul&gt;

        &lt;% if (@$todos || $filter ne 'all') { %&gt;
          &lt;%= include 'todos/_footer',
              active        =&gt; $active,
              has_completed =&gt; (grep { $_-&gt;completed } @$todos) &gt; 0,
              filter        =&gt; $filter %&gt;
        &lt;% } %&gt;
      &lt;/main&gt;
      ```
    </template_list>

    <template_footer>
      ```html
      &lt;!-- templates/todos/_footer.html.ep --&gt;
      &lt;footer class="footer"&gt;
        &lt;span&gt;
          &lt;strong&gt;&lt;%= $active %&gt;&lt;/strong&gt; &lt;%= pluralize($active, 'item') %&gt; left
        &lt;/span&gt;

        &lt;div class="filters"&gt;
          &lt;a href="&lt;%= route('home') %&gt;"
             class="&lt;%= $filter eq 'all' ? 'selected' : '' %&gt;"
             hx-boost="true"&gt;All&lt;/a&gt;
          &lt;a href="&lt;%= route('active') %&gt;"
             class="&lt;%= $filter eq 'active' ? 'selected' : '' %&gt;"
             hx-boost="true"&gt;Active&lt;/a&gt;
          &lt;a href="&lt;%= route('completed') %&gt;"
             class="&lt;%= $filter eq 'completed' ? 'selected' : '' %&gt;"
             hx-boost="true"&gt;Completed&lt;/a&gt;
        &lt;/div&gt;

        &lt;% if ($has_completed) { %&gt;
          &lt;button &lt;%= hx_post(route('todos_clear'),
                              target =&gt; 'closest main',
                              swap   =&gt; 'outerHTML') %&gt;&gt;
            Clear completed
          &lt;/button&gt;
        &lt;% } %&gt;
      &lt;/footer&gt;
      ```
    </template_footer>
  </example_application>

  <testing_strategy>
    <unit_tests>
      <view_tests>
        - Template compilation from string
        - Template compilation from file
        - Variable interpolation
        - Auto-escaping behavior
        - Raw output with raw()
        - include() partial rendering
        - Helper invocation
        - Template caching
        - Error reporting with line numbers
      </view_tests>

      <layout_tests>
        - extends() with layout
        - block() definition
        - content output in layouts
        - content_for() named blocks
        - Nested layouts
        - Missing block handling
      </layout_tests>

      <htmx_helper_tests>
        - hx_get() attribute generation
        - hx_post() attribute generation
        - hx_delete() with confirm
        - All option handling (target, swap, trigger, etc.)
        - hx_sse() connection attributes
        - hx_ws() connection attributes
        - htmx() script tag generation
      </htmx_helper_tests>

      <model_tests>
        - Model instantiation via for_context
        - Factory pattern (new instance each call)
        - Per-request caching role
        - Model config passing
        - Context access via c()
        - Async for_context support
      </model_tests>

      <discovery_tests>
        - Auto-discovery of models in namespace
        - Nested namespace handling (Foo::Bar)
        - Missing model error handling
        - Compilation error handling
        - Discovery caching
      </discovery_tests>
    </unit_tests>

    <integration_tests>
      <htmx_request_tests>
        - is_htmx detection
        - Fragment vs full page rendering
        - render_or_redirect behavior
        - empty_or_redirect behavior
        - hx_trigger response header
        - hx_redirect response header
      </htmx_request_tests>

      <valiant_tests>
        - form_for with valid model
        - form_for with invalid model (errors)
        - Input value population
        - Error display with errors_for
        - Model-level errors
        - fields_for with collection
        - fields_for with _destroy
        - Inline validation via htmx
      </valiant_tests>

      <to_html_tests>
        - Object with TO_HTML renders in template
        - TO_HTML receives view context
        - TO_HTML can call include()
        - Object without TO_HTML stringifies
      </to_html_tests>

      <route_tests>
        - route() URL generation
        - Path parameter substitution
        - Query parameter handling
        - Missing route handling
        - Integration with hx_* helpers
      </route_tests>
    </integration_tests>

    <example_app_tests>
      <todo_app_tests>
        - List todos on home page
        - Create new todo
        - Create todo with validation error
        - Toggle todo completion
        - Edit todo inline
        - Delete todo
        - Clear completed
        - Toggle all
        - Filter by status
        - SSE live updates
        - htmx partial updates
        - Progressive enhancement (no JS)
      </todo_app_tests>
    </example_app_tests>

    <test_utilities>
      ```perl
      # t/lib/Test/PAGI/Simple/View.pm
      package Test::PAGI::Simple::View;
      use Test2::V0;
      use PAGI::Simple::View;

      sub create_test_view (%opts) {
          return PAGI::Simple::View-&gt;new(
              template_dir =&gt; $opts{template_dir} // 't/templates',
              auto_escape  =&gt; $opts{auto_escape} // 1,
              cache        =&gt; 0,  # Disable caching for tests
              %opts,
          );
      }

      sub render_template ($view, $template, %vars) {
          return $view-&gt;render_string($template, %vars);
      }

      sub assert_html_contains ($html, $expected, $name = undef) {
          like($html, qr/\Q$expected\E/, $name // "HTML contains: $expected");
      }

      sub assert_html_matches ($html, $pattern, $name = undef) {
          like($html, $pattern, $name // "HTML matches pattern");
      }

      sub create_mock_context (%opts) {
          # Create mock context for testing
      }

      1;
      ```
    </test_utilities>
  </testing_strategy>

  <success_criteria>
    <view_system>
      - Templates render correctly with Template::EmbeddedPerl
      - Auto-escaping prevents XSS
      - Layouts work with extends/block/content
      - Partials include correctly
      - Template caching improves performance
      - Development mode provides helpful errors
    </view_system>

    <htmx_integration>
      - All hx_* helpers generate correct attributes
      - Auto-fragment detection works seamlessly
      - render_or_redirect handles both cases
      - HX-Trigger headers set correctly
      - WebSocket/SSE extensions work
    </htmx_integration>

    <model_layer>
      - Auto-discovery finds all models
      - Factory pattern is default
      - Per-request caching opt-in works
      - Async models work correctly
      - Configuration passed to models
    </model_layer>

    <valiant_integration>
      - form_for binds to models
      - Inputs populated from model
      - Errors displayed correctly
      - fields_for handles collections
      - Inline validation works with htmx
      - Role is cleanly isolated for extraction
    </valiant_integration>

    <developer_experience>
      - Clear error messages
      - Template line numbers in errors
      - Development mode auto-reload
      - Comprehensive documentation
      - Working example applications
    </developer_experience>
  </success_criteria>
</project_specification>
