# PAGI::SSE Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a Starlette-inspired SSE helper that wraps raw PAGI SSE protocol with a clean, consistent API matching PAGI::WebSocket.

**Architecture:** PAGI::SSE wraps scope/receive/send like PAGI::WebSocket. Uses `send` verb for consistency. Provides send_event for full SSE fields, send/send_json shortcuts, keepalive timer, and iteration helpers. Borrows patterns from PAGI::Simple::SSE and better-sse.

**Tech Stack:** Perl 5.16+, Future::AsyncAwait, JSON::PP, IO::Async (for keepalive timer), Test2::V0

---

## Task 1: Constructor and Basic Accessors

**Files:**
- Create: `lib/PAGI/SSE.pm`
- Create: `t/sse/01-constructor.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'constructor requires scope, receive, send' => sub {
    like(
        dies { PAGI::SSE->new },
        qr/requires scope/,
        'dies without scope'
    );

    like(
        dies { PAGI::SSE->new({}) },
        qr/requires receive/,
        'dies without receive'
    );

    like(
        dies { PAGI::SSE->new({}, sub {}) },
        qr/requires send/,
        'dies without send'
    );
};

subtest 'constructor validates scope type' => sub {
    like(
        dies { PAGI::SSE->new({ type => 'http' }, sub {}, sub {}) },
        qr/requires scope type 'sse'/,
        'dies with wrong scope type'
    );

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub {});
    isa_ok($sse, 'PAGI::SSE');
};

subtest 'basic accessors' => sub {
    my $scope = {
        type         => 'sse',
        path         => '/events',
        query_string => 'token=abc',
        scheme       => 'https',
        headers      => [
            ['last-event-id', '42'],
            ['authorization', 'Bearer xyz'],
        ],
    };
    my $receive = sub { Future->done };
    my $send = sub { Future->done };

    my $sse = PAGI::SSE->new($scope, $receive, $send);

    is($sse->path, '/events', 'path accessor');
    is($sse->query_string, 'token=abc', 'query_string accessor');
    is($sse->scheme, 'https', 'scheme accessor');
    is($sse->scope, $scope, 'scope accessor returns hashref');
    ref_ok($sse->stash, 'HASH', 'stash returns hashref');
};

subtest 'header accessors' => sub {
    my $scope = {
        type    => 'sse',
        headers => [
            ['last-event-id', '42'],
            ['cookie', 'a=1'],
            ['cookie', 'b=2'],
        ],
    };

    my $sse = PAGI::SSE->new($scope, sub {}, sub {});

    is($sse->header('last-event-id'), '42', 'single header lookup');
    is($sse->header('Last-Event-ID'), '42', 'header lookup case-insensitive');
    is($sse->header('x-missing'), undef, 'missing header returns undef');

    my @cookies = $sse->header_all('cookie');
    is(\@cookies, ['a=1', 'b=2'], 'header_all returns all values');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/01-constructor.t`
Expected: FAIL with "Can't locate PAGI/SSE.pm"

**Step 3: Create directory and write minimal implementation**

```bash
mkdir -p t/sse
```

```perl
package PAGI::SSE;
use strict;
use warnings;
use Carp qw(croak);
use Hash::MultiValue;
use Future::AsyncAwait;
use Future;
use JSON::PP ();
use Scalar::Util qw(blessed);

our $VERSION = '0.01';

sub new {
    my ($class, $scope, $receive, $send) = @_;

    croak "PAGI::SSE requires scope hashref"
        unless $scope && ref($scope) eq 'HASH';
    croak "PAGI::SSE requires receive coderef"
        unless $receive && ref($receive) eq 'CODE';
    croak "PAGI::SSE requires send coderef"
        unless $send && ref($send) eq 'CODE';
    croak "PAGI::SSE requires scope type 'sse', got '$scope->{type}'"
        unless ($scope->{type} // '') eq 'sse';

    return bless {
        scope     => $scope,
        receive   => $receive,
        send      => $send,
        _state    => 'pending',  # pending -> started -> closed
        _on_close => [],
        _on_error => [],
        _stash    => {},
    }, $class;
}

# Scope property accessors
sub scope        { shift->{scope} }
sub path         { shift->{scope}{path} // '/' }
sub raw_path     { my $s = shift; $s->{scope}{raw_path} // $s->{scope}{path} // '/' }
sub query_string { shift->{scope}{query_string} // '' }
sub scheme       { shift->{scope}{scheme} // 'http' }
sub http_version { shift->{scope}{http_version} // '1.1' }
sub client       { shift->{scope}{client} }
sub server       { shift->{scope}{server} }

# Per-connection storage
sub stash        { shift->{_stash} }

# Single header lookup (case-insensitive, returns last value)
sub header {
    my ($self, $name) = @_;
    $name = lc($name);
    my $value;
    for my $pair (@{$self->{scope}{headers} // []}) {
        if (lc($pair->[0]) eq $name) {
            $value = $pair->[1];
        }
    }
    return $value;
}

# All headers as Hash::MultiValue (cached)
sub headers {
    my $self = shift;
    return $self->{_headers} if $self->{_headers};

    my @pairs;
    for my $pair (@{$self->{scope}{headers} // []}) {
        push @pairs, lc($pair->[0]), $pair->[1];
    }

    $self->{_headers} = Hash::MultiValue->new(@pairs);
    return $self->{_headers};
}

# All values for a header
sub header_all {
    my ($self, $name) = @_;
    return $self->headers->get_all(lc($name));
}

1;
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/01-constructor.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/01-constructor.t
git commit -m "feat(sse): add PAGI::SSE constructor and basic accessors"
```

---

## Task 2: State Management

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/02-state.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'initial state is pending' => sub {
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub {});

    is($sse->state, 'pending', 'initial state is pending');
    ok(!$sse->is_started, 'is_started is false');
    ok(!$sse->is_closed, 'is_closed is false');
};

subtest 'state transitions' => sub {
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub {});

    $sse->_set_state('started');
    is($sse->state, 'started', 'state is started');
    ok($sse->is_started, 'is_started is true');
    ok(!$sse->is_closed, 'is_closed is false');

    $sse->_set_closed;
    is($sse->state, 'closed', 'state is closed');
    ok(!$sse->is_started, 'is_started is false after close');
    ok($sse->is_closed, 'is_closed is true');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/02-state.t`
Expected: FAIL with "Can't locate object method"

**Step 3: Add state methods to SSE.pm**

```perl
# State accessors
sub state { shift->{_state} }

sub is_started {
    my $self = shift;
    return $self->{_state} eq 'started';
}

sub is_closed {
    my $self = shift;
    return $self->{_state} eq 'closed';
}

# Internal state setters
sub _set_state {
    my ($self, $state) = @_;
    $self->{_state} = $state;
}

sub _set_closed {
    my ($self) = @_;
    $self->{_state} = 'closed';
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/02-state.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/02-state.t
git commit -m "feat(sse): add state management (pending/started/closed)"
```

---

## Task 3: Start Method

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/03-start.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'start sends sse.start event' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);

    $sse->start->get;

    is(scalar @sent, 1, 'one event sent');
    is($sent[0]{type}, 'sse.start', 'event type is sse.start');
    is($sent[0]{status}, 200, 'default status is 200');
    ok($sse->is_started, 'is_started is true after start');
};

subtest 'start with custom status and headers' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);

    $sse->start(
        status  => 201,
        headers => [['x-custom', 'value']],
    )->get;

    is($sent[0]{status}, 201, 'custom status');
    is($sent[0]{headers}, [['x-custom', 'value']], 'custom headers');
};

subtest 'start is idempotent' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);

    $sse->start->get;
    $sse->start->get;
    $sse->start->get;

    is(scalar @sent, 1, 'start only sends once');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/03-start.t`
Expected: FAIL with "Can't locate object method 'start'"

**Step 3: Add start method**

```perl
# Start the SSE stream
async sub start {
    my ($self, %opts) = @_;

    # Idempotent - don't start twice
    return $self if $self->is_started || $self->is_closed;

    my $event = {
        type   => 'sse.start',
        status => $opts{status} // 200,
    };
    $event->{headers} = $opts{headers} if exists $opts{headers};

    await $self->{send}->($event);
    $self->_set_state('started');

    return $self;
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/03-start.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/03-start.t
git commit -m "feat(sse): add start method for sse.start event"
```

---

## Task 4: Send Methods

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/04-send.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;
use JSON::PP;

use lib 'lib';
use PAGI::SSE;

subtest 'send sends data-only event' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    $sse->send("Hello world")->get;

    is($sent[1]{type}, 'sse.send', 'event type is sse.send');
    is($sent[1]{data}, 'Hello world', 'data is set');
    ok(!exists $sent[1]{event}, 'no event field');
    ok(!exists $sent[1]{id}, 'no id field');
};

subtest 'send_json encodes as JSON' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    $sse->send_json({ message => "hello", count => 42 })->get;

    my $decoded = JSON::PP::decode_json($sent[1]{data});
    is($decoded->{message}, 'hello', 'JSON message field');
    is($decoded->{count}, 42, 'JSON count field');
};

subtest 'send_event with all fields' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    $sse->send_event(
        data  => { type => 'notification' },
        event => 'alert',
        id    => 'msg-123',
        retry => 5000,
    )->get;

    is($sent[1]{type}, 'sse.send', 'event type is sse.send');
    is($sent[1]{event}, 'alert', 'event name');
    is($sent[1]{id}, 'msg-123', 'event id');
    is($sent[1]{retry}, 5000, 'retry value');

    my $decoded = JSON::PP::decode_json($sent[1]{data});
    is($decoded->{type}, 'notification', 'data was JSON encoded');
};

subtest 'send_event with string data' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    $sse->send_event(data => "plain text")->get;

    is($sent[1]{data}, 'plain text', 'string data not encoded');
};

subtest 'send auto-starts if not started' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);

    # Send without calling start first
    $sse->send("Hello")->get;

    is(scalar @sent, 2, 'two events sent');
    is($sent[0]{type}, 'sse.start', 'first was sse.start');
    is($sent[1]{type}, 'sse.send', 'second was sse.send');
};

subtest 'send on closed connection dies' => sub {
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub { Future->done });
    $sse->_set_closed;

    like(
        dies { $sse->send("test")->get },
        qr/Cannot send on closed SSE/,
        'send on closed dies'
    );
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/04-send.t`
Expected: FAIL

**Step 3: Add send methods**

```perl
# Send data-only event
async sub send {
    my ($self, $data) = @_;

    croak "Cannot send on closed SSE connection" if $self->is_closed;

    # Auto-start if not started
    await $self->start unless $self->is_started;

    await $self->{send}->({
        type => 'sse.send',
        data => $data,
    });

    return $self;
}

# Send JSON-encoded data
async sub send_json {
    my ($self, $data) = @_;

    croak "Cannot send on closed SSE connection" if $self->is_closed;

    await $self->start unless $self->is_started;

    my $json = JSON::PP::encode_json($data);

    await $self->{send}->({
        type => 'sse.send',
        data => $json,
    });

    return $self;
}

# Send full SSE event with all fields
async sub send_event {
    my ($self, %opts) = @_;

    croak "Cannot send on closed SSE connection" if $self->is_closed;
    croak "send_event requires 'data' parameter" unless exists $opts{data};

    await $self->start unless $self->is_started;

    # Auto-encode hashref/arrayref data as JSON
    my $data = $opts{data};
    if (ref $data) {
        $data = JSON::PP::encode_json($data);
    }

    my $event = {
        type => 'sse.send',
        data => $data,
    };

    $event->{event} = $opts{event} if defined $opts{event};
    $event->{id}    = "$opts{id}"  if defined $opts{id};
    $event->{retry} = int($opts{retry}) if defined $opts{retry};

    await $self->{send}->($event);

    return $self;
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/04-send.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/04-send.t
git commit -m "feat(sse): add send, send_json, send_event methods"
```

---

## Task 5: Safe Send Methods (try_send*)

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/05-safe-send.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'try_send returns true on success' => sub {
    my $send = sub { Future->done };
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    my $result = $sse->try_send("Hello")->get;
    ok($result, 'try_send returns true on success');
};

subtest 'try_send returns false when closed' => sub {
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub { Future->done });
    $sse->_set_closed;

    my $result = $sse->try_send("Hello")->get;
    ok(!$result, 'try_send returns false when closed');
};

subtest 'try_send returns false on send error' => sub {
    my $send = sub { Future->fail("Connection lost") };
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    # Mark as started to avoid auto-start
    $sse->_set_state('started');

    my $result = $sse->try_send("Hello")->get;
    ok(!$result, 'try_send returns false on error');
    ok($sse->is_closed, 'connection marked as closed after error');
};

subtest 'try_send_json works' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    my $result = $sse->try_send_json({ foo => 'bar' })->get;
    ok($result, 'try_send_json returns true');
    like($sent[1]{data}, qr/"foo"/, 'JSON was sent');
};

subtest 'try_send_event works' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    my $result = $sse->try_send_event(
        data  => 'test',
        event => 'ping',
    )->get;

    ok($result, 'try_send_event returns true');
    is($sent[1]{event}, 'ping', 'event name sent');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/05-safe-send.t`
Expected: FAIL

**Step 3: Add try_send methods**

```perl
# Safe send - returns bool instead of throwing
async sub try_send {
    my ($self, $data) = @_;
    return 0 if $self->is_closed;

    eval {
        await $self->start unless $self->is_started;
        await $self->{send}->({
            type => 'sse.send',
            data => $data,
        });
    };
    if ($@) {
        $self->_set_closed;
        return 0;
    }
    return 1;
}

async sub try_send_json {
    my ($self, $data) = @_;
    return 0 if $self->is_closed;

    eval {
        await $self->start unless $self->is_started;
        my $json = JSON::PP::encode_json($data);
        await $self->{send}->({
            type => 'sse.send',
            data => $json,
        });
    };
    if ($@) {
        $self->_set_closed;
        return 0;
    }
    return 1;
}

async sub try_send_event {
    my ($self, %opts) = @_;
    return 0 if $self->is_closed;

    eval {
        await $self->start unless $self->is_started;

        my $data = $opts{data} // '';
        if (ref $data) {
            $data = JSON::PP::encode_json($data);
        }

        my $event = {
            type => 'sse.send',
            data => $data,
        };
        $event->{event} = $opts{event} if defined $opts{event};
        $event->{id}    = "$opts{id}"  if defined $opts{id};
        $event->{retry} = int($opts{retry}) if defined $opts{retry};

        await $self->{send}->($event);
    };
    if ($@) {
        $self->_set_closed;
        return 0;
    }
    return 1;
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/05-safe-send.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/05-safe-send.t
git commit -m "feat(sse): add try_send, try_send_json, try_send_event methods"
```

---

## Task 6: Lifecycle (on_close, close, run)

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/06-lifecycle.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'on_close registers callback' => sub {
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub { Future->done });

    my $called = 0;
    $sse->on_close(sub { $called = 1 });

    ok(!$called, 'callback not called yet');
};

subtest 'run waits for disconnect and calls on_close' => sub {
    my @events = (
        { type => 'sse.disconnect' },
    );
    my $idx = 0;
    my $receive = sub { Future->done($events[$idx++]) };
    my $send = sub { Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, $receive, $send);
    $sse->start->get;

    my $cleanup_ran = 0;
    $sse->on_close(sub { $cleanup_ran = 1 });

    $sse->run->get;

    ok($cleanup_ran, 'on_close callback ran');
    ok($sse->is_closed, 'connection is closed');
};

subtest 'multiple on_close callbacks run in order' => sub {
    my @events = ({ type => 'sse.disconnect' });
    my $idx = 0;
    my $receive = sub { Future->done($events[$idx++]) };

    my $sse = PAGI::SSE->new({ type => 'sse' }, $receive, sub { Future->done });
    $sse->start->get;

    my @order;
    $sse->on_close(sub { push @order, 1 });
    $sse->on_close(sub { push @order, 2 });
    $sse->on_close(sub { push @order, 3 });

    $sse->run->get;

    is(\@order, [1, 2, 3], 'callbacks run in registration order');
};

subtest 'on_close works with async callbacks' => sub {
    my @events = ({ type => 'sse.disconnect' });
    my $idx = 0;
    my $receive = sub { Future->done($events[$idx++]) };

    my $sse = PAGI::SSE->new({ type => 'sse' }, $receive, sub { Future->done });
    $sse->start->get;

    my $async_ran = 0;
    $sse->on_close(async sub { $async_ran = 1 });

    $sse->run->get;

    ok($async_ran, 'async callback ran');
};

subtest 'close method sets closed state' => sub {
    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, sub { Future->done });
    $sse->start->get;

    my $cleanup_ran = 0;
    $sse->on_close(sub { $cleanup_ran = 1 });

    $sse->close;

    ok($sse->is_closed, 'is_closed is true');
    ok($cleanup_ran, 'on_close ran on explicit close');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/06-lifecycle.t`
Expected: FAIL

**Step 3: Add lifecycle methods**

```perl
# Register close callback
sub on_close {
    my ($self, $callback) = @_;
    push @{$self->{_on_close}}, $callback;
    return $self;
}

# Register error callback
sub on_error {
    my ($self, $callback) = @_;
    push @{$self->{_on_error}}, $callback;
    return $self;
}

# Internal: run all on_close callbacks
async sub _run_close_callbacks {
    my ($self) = @_;

    # Only run once
    return if $self->{_close_callbacks_ran};
    $self->{_close_callbacks_ran} = 1;

    for my $cb (@{$self->{_on_close}}) {
        eval {
            my $r = $cb->($self);
            if (blessed($r) && $r->isa('Future')) {
                await $r;
            }
        };
        if ($@) {
            warn "PAGI::SSE on_close callback error: $@";
        }
    }
}

# Close the connection
sub close {
    my ($self) = @_;

    return $self if $self->is_closed;

    $self->_set_closed;
    $self->_run_close_callbacks->get;

    return $self;
}

# Wait for disconnect
async sub run {
    my ($self) = @_;

    await $self->start unless $self->is_started;

    while (!$self->is_closed) {
        my $event = await $self->{receive}->();
        my $type = $event->{type} // '';

        if ($type eq 'sse.disconnect') {
            $self->_set_closed;
            await $self->_run_close_callbacks;
            last;
        }
    }

    return;
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/06-lifecycle.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/06-lifecycle.t
git commit -m "feat(sse): add on_close, close, run lifecycle methods"
```

---

## Task 7: last_event_id Helper

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/07-last-event-id.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;

use lib 'lib';
use PAGI::SSE;

subtest 'last_event_id returns header value' => sub {
    my $scope = {
        type    => 'sse',
        headers => [
            ['last-event-id', '42'],
        ],
    };

    my $sse = PAGI::SSE->new($scope, sub {}, sub {});

    is($sse->last_event_id, '42', 'returns last-event-id header');
};

subtest 'last_event_id is case-insensitive' => sub {
    my $scope = {
        type    => 'sse',
        headers => [
            ['Last-Event-ID', 'abc-123'],
        ],
    };

    my $sse = PAGI::SSE->new($scope, sub {}, sub {});

    is($sse->last_event_id, 'abc-123', 'case-insensitive lookup');
};

subtest 'last_event_id returns undef when missing' => sub {
    my $scope = {
        type    => 'sse',
        headers => [],
    };

    my $sse = PAGI::SSE->new($scope, sub {}, sub {});

    is($sse->last_event_id, undef, 'undef when no header');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/07-last-event-id.t`
Expected: FAIL

**Step 3: Add last_event_id method**

```perl
# Get Last-Event-ID header from client (for reconnection)
sub last_event_id {
    my ($self) = @_;
    return $self->header('last-event-id');
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/07-last-event-id.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/07-last-event-id.t
git commit -m "feat(sse): add last_event_id helper for reconnection"
```

---

## Task 8: Keepalive Timer

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/08-keepalive.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;
use IO::Async::Loop;

use lib 'lib';
use PAGI::SSE;

subtest 'keepalive sends periodic comments' => sub {
    my $loop = IO::Async::Loop->new;
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->set_loop($loop);
    $sse->start->get;

    # Enable keepalive with 0.1 second interval for testing
    $sse->keepalive(0.1);

    # Wait for a couple pings
    $loop->delay_future(after => 0.25)->get;

    # Stop keepalive
    $sse->keepalive(0);

    # Should have sent at least 2 keepalive comments
    my @keepalives = grep { ($_->{data} // '') =~ /^:/ } @sent;
    ok(@keepalives >= 2, 'at least 2 keepalive pings sent');
};

subtest 'keepalive with custom comment' => sub {
    my $loop = IO::Async::Loop->new;
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->set_loop($loop);
    $sse->start->get;

    $sse->keepalive(0.1, ':ping');

    $loop->delay_future(after => 0.15)->get;

    $sse->keepalive(0);

    my @pings = grep { ($_->{data} // '') eq ':ping' } @sent;
    ok(@pings >= 1, 'custom keepalive comment sent');
};

subtest 'keepalive(0) disables timer' => sub {
    my $loop = IO::Async::Loop->new;
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->set_loop($loop);
    $sse->start->get;

    $sse->keepalive(0.1);
    $sse->keepalive(0);  # Disable immediately

    my $before_count = scalar @sent;
    $loop->delay_future(after => 0.2)->get;
    my $after_count = scalar @sent;

    is($after_count, $before_count, 'no keepalive sent after disable');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/08-keepalive.t`
Expected: FAIL

**Step 3: Add keepalive methods**

```perl
# Set or get the event loop
sub set_loop {
    my ($self, $loop) = @_;
    $self->{_loop} = $loop;
    return $self;
}

sub loop {
    my ($self) = @_;
    return $self->{_loop} if $self->{_loop};

    require IO::Async::Loop;
    $self->{_loop} = IO::Async::Loop->new;
    return $self->{_loop};
}

# Enable/disable keepalive timer
sub keepalive {
    my ($self, $interval, $comment) = @_;
    $comment //= ':keepalive';

    # Stop existing timer if any
    if ($self->{_keepalive_timer}) {
        $self->{_keepalive_timer}->stop;
        $self->loop->remove($self->{_keepalive_timer});
        delete $self->{_keepalive_timer};
    }

    # If interval is 0 or undef, just disable
    return $self unless $interval && $interval > 0;

    require IO::Async::Timer::Periodic;
    require Scalar::Util;

    my $weak_self = $self;
    Scalar::Util::weaken($weak_self);

    my $timer = IO::Async::Timer::Periodic->new(
        interval => $interval,
        on_tick  => sub {
            return unless $weak_self && !$weak_self->is_closed;
            $weak_self->try_send($comment);
        },
    );

    $self->loop->add($timer);
    $timer->start;
    $self->{_keepalive_timer} = $timer;

    return $self;
}
```

Also update `_set_closed` to stop keepalive:

```perl
sub _set_closed {
    my ($self) = @_;
    $self->{_state} = 'closed';

    # Stop keepalive timer if running
    if ($self->{_keepalive_timer}) {
        $self->{_keepalive_timer}->stop;
        if ($self->{_loop}) {
            $self->{_loop}->remove($self->{_keepalive_timer});
        }
        delete $self->{_keepalive_timer};
    }
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/08-keepalive.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/08-keepalive.t
git commit -m "feat(sse): add keepalive timer for connection health"
```

---

## Task 9: Iteration Helper (each)

**Files:**
- Modify: `lib/PAGI/SSE.pm`
- Create: `t/sse/09-iteration.t`

**Step 1: Write the failing test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'each iterates over arrayref' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    my @items = ('one', 'two', 'three');

    $sse->each(\@items, async sub {
        my ($item) = @_;
        await $sse->send($item);
    })->get;

    my @data_sent = map { $_->{data} } grep { $_->{type} eq 'sse.send' } @sent;
    is(\@data_sent, ['one', 'two', 'three'], 'all items sent');
};

subtest 'each with transformer returns event spec' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    my @items = ({ name => 'Alice' }, { name => 'Bob' });

    $sse->each(\@items, async sub {
        my ($item, $index) = @_;
        return {
            data  => $item,
            event => 'user',
            id    => $index,
        };
    })->get;

    my @events = grep { $_->{type} eq 'sse.send' } @sent;
    is($events[0]{event}, 'user', 'first event type');
    is($events[0]{id}, '0', 'first event id');
    is($events[1]{id}, '1', 'second event id');
};

subtest 'each with coderef iterator' => sub {
    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $sse = PAGI::SSE->new({ type => 'sse' }, sub {}, $send);
    $sse->start->get;

    my @items = (1, 2, 3);
    my $idx = 0;
    my $iterator = sub {
        return undef if $idx >= @items;
        return $items[$idx++];
    };

    $sse->each($iterator, async sub {
        my ($item) = @_;
        await $sse->send("item: $item");
    })->get;

    my @data_sent = map { $_->{data} } grep { $_->{type} eq 'sse.send' } @sent;
    is(\@data_sent, ['item: 1', 'item: 2', 'item: 3'], 'coderef iterator works');
};

done_testing;
```

**Step 2: Run test to verify it fails**

Run: `prove -l t/sse/09-iteration.t`
Expected: FAIL

**Step 3: Add each method**

```perl
# Iterate over items and send events
async sub each {
    my ($self, $source, $callback) = @_;

    await $self->start unless $self->is_started;

    my $index = 0;

    # Handle arrayref
    if (ref $source eq 'ARRAY') {
        for my $item (@$source) {
            last if $self->is_closed;

            my $result = await $callback->($item, $index++);

            # If callback returns a hashref, treat as event spec
            if (ref $result eq 'HASH') {
                await $self->send_event(%$result);
            }
        }
    }
    # Handle coderef iterator
    elsif (ref $source eq 'CODE') {
        while (!$self->is_closed) {
            my $item = $source->();
            last unless defined $item;

            my $result = await $callback->($item, $index++);

            if (ref $result eq 'HASH') {
                await $self->send_event(%$result);
            }
        }
    }
    else {
        croak "each() requires arrayref or coderef, got " . ref($source);
    }

    return $self;
}
```

**Step 4: Run test to verify it passes**

Run: `prove -l t/sse/09-iteration.t`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/PAGI/SSE.pm t/sse/09-iteration.t
git commit -m "feat(sse): add each() iteration helper"
```

---

## Task 10: Integration Test

**Files:**
- Create: `t/sse/10-integration.t`

**Step 1: Write integration test**

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test2::V0;
use Future::AsyncAwait;
use Future;

use lib 'lib';
use PAGI::SSE;

subtest 'complete SSE session' => sub {
    my @events = (
        { type => 'sse.disconnect' },
    );
    my $idx = 0;
    my $receive = sub { Future->done($events[$idx++]) };

    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $scope = {
        type    => 'sse',
        path    => '/events',
        headers => [['last-event-id', '5']],
    };

    my $sse = PAGI::SSE->new($scope, $receive, $send);

    # Check last event ID
    is($sse->last_event_id, '5', 'got last event id');

    # Register cleanup
    my $cleanup_ran = 0;
    $sse->on_close(sub { $cleanup_ran = 1 });

    # Store data in stash
    $sse->stash->{user_id} = 42;
    is($sse->stash->{user_id}, 42, 'stash works');

    # Start and send events
    $sse->start->get;
    $sse->send_event(data => 'catch-up', id => '6')->get;
    $sse->send_json({ type => 'hello' })->get;

    # Run until disconnect
    $sse->run->get;

    ok($cleanup_ran, 'cleanup ran');
    ok($sse->is_closed, 'connection closed');

    # Verify sent events
    is($sent[0]{type}, 'sse.start', 'start sent');
    is($sent[1]{id}, '6', 'catch-up event with id');
    like($sent[2]{data}, qr/"type".*"hello"/, 'JSON event sent');
};

subtest 'notification stream pattern' => sub {
    my @events = ({ type => 'sse.disconnect' });
    my $idx = 0;
    my $receive = sub { Future->done($events[$idx++]) };

    my @sent;
    my $send = sub { push @sent, $_[0]; Future->done };

    my $scope = { type => 'sse', path => '/notifications' };

    my $sse = PAGI::SSE->new($scope, $receive, $send);

    # Simulate subscriber registration
    my $subscriber_id;
    my $unsubscribed = 0;

    $sse->on_close(sub {
        $unsubscribed = 1;
    });

    $sse->start->get;

    # Send some notifications
    for my $i (1..3) {
        $sse->send_event(
            event => 'notification',
            data  => { id => $i, message => "Notification $i" },
            id    => $i,
        )->get;
    }

    # Client disconnects
    $sse->run->get;

    ok($unsubscribed, 'unsubscribe callback ran');

    my @notifications = grep { ($_->{event} // '') eq 'notification' } @sent;
    is(scalar @notifications, 3, 'all 3 notifications sent');
};

done_testing;
```

**Step 2: Run test**

Run: `prove -l t/sse/10-integration.t`
Expected: PASS

**Step 3: Commit**

```bash
git add t/sse/10-integration.t
git commit -m "test(sse): add integration tests"
```

---

## Task 11: POD Documentation

**Files:**
- Modify: `lib/PAGI/SSE.pm`

**Step 1: Add comprehensive POD**

Add to end of `lib/PAGI/SSE.pm`:

```perl
__END__

=head1 NAME

PAGI::SSE - Convenience wrapper for PAGI Server-Sent Events connections

=head1 SYNOPSIS

    use PAGI::SSE;
    use Future::AsyncAwait;

    # Simple notification stream
    async sub app {
        my ($scope, $receive, $send) = @_;

        my $sse = PAGI::SSE->new($scope, $receive, $send);

        # Enable keepalive for proxy compatibility
        $sse->keepalive(25);

        # Cleanup on disconnect
        $sse->on_close(sub {
            remove_subscriber($sse->stash->{sub_id});
        });

        # Handle reconnection
        if (my $last_id = $sse->last_event_id) {
            my @missed = get_events_since($last_id);
            for my $event (@missed) {
                await $sse->send_event(%$event);
            }
        }

        # Subscribe to updates
        $sse->stash->{sub_id} = add_subscriber(sub {
            my ($event) = @_;
            $sse->try_send_json($event);
        });

        # Wait for disconnect
        await $sse->run;
    }

=head1 DESCRIPTION

PAGI::SSE wraps the raw PAGI SSE protocol to provide a clean,
high-level API inspired by Starlette. It eliminates protocol
boilerplate and provides:

=over 4

=item * Multiple send methods (send, send_json, send_event)

=item * Connection state tracking (is_started, is_closed)

=item * Cleanup callback registration (on_close)

=item * Safe send methods for broadcast scenarios (try_send_*)

=item * Reconnection support (last_event_id)

=item * Keepalive timer for proxy compatibility

=item * Iteration helper (each)

=item * Per-connection storage (stash)

=back

=head1 CONSTRUCTOR

=head2 new

    my $sse = PAGI::SSE->new($scope, $receive, $send);

Creates a new SSE wrapper. Requires:

=over 4

=item * C<$scope> - PAGI scope hashref with C<type => 'sse'>

=item * C<$receive> - Async coderef returning Futures for events

=item * C<$send> - Async coderef for sending events

=back

Dies if scope type is not 'sse'.

=head1 SCOPE ACCESSORS

=head2 scope, path, raw_path, query_string, scheme, http_version

    my $path = $sse->path;              # /events
    my $qs = $sse->query_string;        # token=abc

=head2 header, headers, header_all

    my $auth = $sse->header('authorization');
    my @cookies = $sse->header_all('cookie');

=head2 last_event_id

    my $id = $sse->last_event_id;       # From Last-Event-ID header

Returns the Last-Event-ID header sent by reconnecting clients.
Use this to replay missed events.

=head2 stash

    $sse->stash->{user} = $user;

Per-connection storage hashref.

=head1 LIFECYCLE METHODS

=head2 start

    await $sse->start;
    await $sse->start(status => 200, headers => [...]);

Starts the SSE stream. Called automatically on first send.
Idempotent - only sends sse.start once.

=head2 close

    $sse->close;

Marks connection as closed and runs on_close callbacks.

=head2 run

    await $sse->run;

Waits for client disconnect. Use this at the end of your
handler to keep the connection open.

=head1 STATE ACCESSORS

=head2 is_started, is_closed, state

    if ($sse->is_started) { ... }
    if ($sse->is_closed) { ... }
    my $state = $sse->state;    # 'pending', 'started', 'closed'

=head1 SEND METHODS

=head2 send

    await $sse->send("Hello world");

Sends a data-only event.

=head2 send_json

    await $sse->send_json({ type => 'update', data => $payload });

JSON-encodes data before sending.

=head2 send_event

    await $sse->send_event(
        data  => $data,              # Required (auto JSON-encodes refs)
        event => 'notification',     # Optional event type
        id    => 'msg-123',          # Optional event ID
        retry => 5000,               # Optional reconnect hint (ms)
    );

Sends a full SSE event with all fields.

=head2 try_send, try_send_json, try_send_event

    my $ok = await $sse->try_send_json($data);
    if (!$ok) {
        # Client disconnected
    }

Returns true on success, false on failure. Does not throw.
Useful for broadcasting to multiple clients.

=head1 KEEPALIVE

=head2 keepalive

    $sse->keepalive(30);              # Ping every 30 seconds
    $sse->keepalive(30, ':ping');     # Custom comment text
    $sse->keepalive(0);               # Disable

Sends periodic comment pings to prevent proxy timeouts.
Requires an event loop (auto-created if needed).

=head1 ITERATION

=head2 each

    # Simple iteration
    await $sse->each(\@items, async sub {
        my ($item) = @_;
        await $sse->send_json($item);
    });

    # With transformer - return event spec
    await $sse->each(\@items, async sub {
        my ($item, $index) = @_;
        return {
            data  => $item,
            event => 'item',
            id    => $index,
        };
    });

    # Coderef iterator
    await $sse->each($iterator_sub, async sub { ... });

Iterates over items, calling callback for each.
If callback returns a hashref, sends it as an event.

=head1 EVENT CALLBACKS

=head2 on_close

    $sse->on_close(sub {
        my ($sse) = @_;
        cleanup_resources();
    });

Registers cleanup callback. Runs on disconnect or close().
Multiple callbacks run in registration order.

=head2 on_error

    $sse->on_error(sub {
        my ($sse, $error) = @_;
        warn "SSE error: $error";
    });

Registers error callback.

=head1 EXAMPLE: LIVE DASHBOARD

    async sub dashboard_sse {
        my ($scope, $receive, $send) = @_;

        my $sse = PAGI::SSE->new($scope, $receive, $send);

        $sse->keepalive(25);

        # Send initial state
        await $sse->send_event(
            event => 'connected',
            data  => { time => time() },
        );

        # Subscribe to metrics
        my $sub_id = subscribe_metrics(sub {
            my ($metrics) = @_;
            $sse->try_send_event(
                event => 'metrics',
                data  => $metrics,
            );
        });

        $sse->on_close(sub {
            unsubscribe_metrics($sub_id);
        });

        await $sse->run;
    }

=head1 SEE ALSO

L<PAGI::WebSocket> - Similar wrapper for WebSocket connections

L<PAGI::Server> - PAGI protocol server

=head1 AUTHOR

PAGI Contributors

=cut
```

**Step 2: Verify POD**

Run: `perl -Ilib -c lib/PAGI/SSE.pm && podchecker lib/PAGI/SSE.pm`
Expected: "lib/PAGI/SSE.pm syntax OK" and no POD errors

**Step 3: Commit**

```bash
git add lib/PAGI/SSE.pm
git commit -m "docs(sse): add comprehensive POD documentation"
```

---

## Task 12: Example App - Live Dashboard

**Files:**
- Create: `examples/sse-dashboard/app.pl`
- Create: `examples/sse-dashboard/public/index.html`

**Step 1: Create example app**

```perl
#!/usr/bin/env perl
#
# Live Dashboard using PAGI::SSE
#
# Demonstrates real-time server metrics streaming with:
# - Automatic keepalive for proxy compatibility
# - Reconnection support via Last-Event-ID
# - Multiple event types
#
# Run: pagi-server --app examples/sse-dashboard/app.pl --port 5000
# Open: http://localhost:5000/
#

use strict;
use warnings;
use Future::AsyncAwait;
use IO::Async::Loop;
use IO::Async::Timer::Periodic;
use File::Basename qw(dirname);
use File::Spec;

use lib 'lib';
use PAGI::SSE;

# Shared state
my %subscribers;
my $next_id = 1;
my $event_id = 0;
my $loop;

# Metrics timer
my $metrics_timer;

sub start_metrics_broadcaster {
    return if $metrics_timer;

    $loop //= IO::Async::Loop->new;

    $metrics_timer = IO::Async::Timer::Periodic->new(
        interval => 2,
        on_tick  => sub {
            $event_id++;

            my $metrics = {
                cpu     => 20 + int(rand(60)),
                memory  => 40 + int(rand(40)),
                requests => int(rand(1000)),
                timestamp => time(),
            };

            for my $sub (values %subscribers) {
                $sub->{sse}->try_send_event(
                    event => 'metrics',
                    data  => $metrics,
                    id    => $event_id,
                );
            }
        },
    );

    $loop->add($metrics_timer);
    $metrics_timer->start;
}

sub stop_metrics_broadcaster {
    return unless $metrics_timer && !%subscribers;

    $metrics_timer->stop;
    $loop->remove($metrics_timer);
    $metrics_timer = undef;
}

# Static file serving
my $public_dir = File::Spec->catdir(dirname(__FILE__), 'public');

my %mime_types = (
    html => 'text/html; charset=utf-8',
    css  => 'text/css; charset=utf-8',
    js   => 'application/javascript; charset=utf-8',
);

async sub serve_static {
    my ($scope, $send, $path) = @_;

    $path = '/index.html' if $path eq '/';
    $path =~ s/\.\.//g;

    my $file_path = File::Spec->catfile($public_dir, $path);

    unless (-f $file_path && -r $file_path) {
        await $send->({ type => 'http.response.start', status => 404, headers => [] });
        await $send->({ type => 'http.response.body', body => 'Not Found' });
        return;
    }

    my ($ext) = $file_path =~ /\.(\w+)$/;
    my $content_type = $mime_types{lc($ext // '')} // 'text/plain';

    open my $fh, '<:raw', $file_path or die;
    local $/;
    my $content = <$fh>;
    close $fh;

    await $send->({
        type    => 'http.response.start',
        status  => 200,
        headers => [
            ['content-type', $content_type],
            ['content-length', length($content)],
        ],
    });
    await $send->({ type => 'http.response.body', body => $content });
}

# Main app
my $app = async sub {
    my ($scope, $receive, $send) = @_;
    my $type = $scope->{type} // '';
    my $path = $scope->{path} // '/';

    # Handle lifespan
    if ($type eq 'lifespan') {
        while (1) {
            my $event = await $receive->();
            if ($event->{type} eq 'lifespan.startup') {
                await $send->({ type => 'lifespan.startup.complete' });
            }
            elsif ($event->{type} eq 'lifespan.shutdown') {
                await $send->({ type => 'lifespan.shutdown.complete' });
                last;
            }
        }
        return;
    }

    # SSE endpoint
    if ($type eq 'sse' && $path eq '/events') {
        my $sse = PAGI::SSE->new($scope, $receive, $send);

        my $sub_id = $next_id++;
        $subscribers{$sub_id} = { sse => $sse };

        # Enable keepalive
        $sse->keepalive(25);

        # Send welcome event
        await $sse->send_event(
            event => 'connected',
            data  => {
                subscriber_id => $sub_id,
                server_time   => time(),
            },
        );

        # Handle reconnection
        if (my $last_id = $sse->last_event_id) {
            await $sse->send_event(
                event => 'reconnected',
                data  => { last_id => $last_id },
            );
        }

        # Start broadcaster if first subscriber
        start_metrics_broadcaster();

        # Cleanup on disconnect
        $sse->on_close(sub {
            delete $subscribers{$sub_id};
            stop_metrics_broadcaster();
            print STDERR "SSE client $sub_id disconnected\n";
        });

        print STDERR "SSE client $sub_id connected\n";

        # Wait for disconnect
        await $sse->run;
        return;
    }

    # HTTP - serve static files
    if ($type eq 'http') {
        await serve_static($scope, $send, $path);
        return;
    }

    die "Unsupported scope type: $type";
};

$app;
```

**Step 2: Create HTML frontend**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAGI SSE Dashboard</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 2rem;
        }
        h1 { margin-bottom: 1rem; color: #00d9ff; }
        .status {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            display: inline-block;
        }
        .status.connected { background: #0a3d0a; color: #4caf50; }
        .status.disconnected { background: #3d0a0a; color: #f44336; }
        .status.connecting { background: #3d3d0a; color: #ff9800; }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .card {
            background: #16213e;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }
        .card .label { color: #888; font-size: 0.875rem; margin-bottom: 0.5rem; }
        .card .value { font-size: 2.5rem; font-weight: bold; color: #00d9ff; }
        .card .unit { font-size: 1rem; color: #666; }
        .events {
            background: #16213e;
            border-radius: 8px;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }
        .events h3 { margin-bottom: 0.5rem; color: #888; }
        .event {
            font-family: monospace;
            font-size: 0.75rem;
            padding: 0.25rem 0;
            border-bottom: 1px solid #1a1a2e;
            color: #aaa;
        }
        .event .type { color: #00d9ff; }
    </style>
</head>
<body>
    <h1>PAGI Live Dashboard</h1>
    <div id="status" class="status connecting">Connecting...</div>

    <div class="grid">
        <div class="card">
            <div class="label">CPU Usage</div>
            <div class="value"><span id="cpu">--</span><span class="unit">%</span></div>
        </div>
        <div class="card">
            <div class="label">Memory Usage</div>
            <div class="value"><span id="memory">--</span><span class="unit">%</span></div>
        </div>
        <div class="card">
            <div class="label">Requests/sec</div>
            <div class="value"><span id="requests">--</span></div>
        </div>
        <div class="card">
            <div class="label">Last Update</div>
            <div class="value" style="font-size: 1.25rem"><span id="timestamp">--</span></div>
        </div>
    </div>

    <div class="events">
        <h3>Event Log</h3>
        <div id="event-log"></div>
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const cpuEl = document.getElementById('cpu');
        const memoryEl = document.getElementById('memory');
        const requestsEl = document.getElementById('requests');
        const timestampEl = document.getElementById('timestamp');
        const eventLog = document.getElementById('event-log');

        let eventSource;

        function connect() {
            statusEl.className = 'status connecting';
            statusEl.textContent = 'Connecting...';

            eventSource = new EventSource('/events');

            eventSource.onopen = () => {
                statusEl.className = 'status connected';
                statusEl.textContent = 'Connected';
                logEvent('open', 'Connection established');
            };

            eventSource.onerror = () => {
                statusEl.className = 'status disconnected';
                statusEl.textContent = 'Disconnected - Reconnecting...';
                logEvent('error', 'Connection lost');
            };

            eventSource.addEventListener('connected', (e) => {
                const data = JSON.parse(e.data);
                logEvent('connected', `Subscriber ID: ${data.subscriber_id}`);
            });

            eventSource.addEventListener('reconnected', (e) => {
                const data = JSON.parse(e.data);
                logEvent('reconnected', `Resumed from ID: ${data.last_id}`);
            });

            eventSource.addEventListener('metrics', (e) => {
                const data = JSON.parse(e.data);
                cpuEl.textContent = data.cpu;
                memoryEl.textContent = data.memory;
                requestsEl.textContent = data.requests;
                timestampEl.textContent = new Date(data.timestamp * 1000).toLocaleTimeString();
                logEvent('metrics', `CPU: ${data.cpu}%, Mem: ${data.memory}%`);
            });
        }

        function logEvent(type, message) {
            const div = document.createElement('div');
            div.className = 'event';
            div.innerHTML = `<span class="type">[${type}]</span> ${message}`;
            eventLog.insertBefore(div, eventLog.firstChild);

            // Keep only last 50 events
            while (eventLog.children.length > 50) {
                eventLog.removeChild(eventLog.lastChild);
            }
        }

        connect();
    </script>
</body>
</html>
```

**Step 3: Test the example**

Run: `timeout 10 perl -Ilib bin/pagi-server --app examples/sse-dashboard/app.pl --port 5555 2>&1 || true`
Expected: Server starts and logs show lifespan startup

**Step 4: Commit**

```bash
git add examples/sse-dashboard/
git commit -m "example(sse): add live dashboard demo with PAGI::SSE"
```

---

## Task 13: Final Test Suite Run

**Step 1: Run all SSE tests**

Run: `prove -l t/sse/`
Expected: All tests pass

**Step 2: Run full test suite**

Run: `prove -l t/`
Expected: No regressions

**Step 3: Final commit with version bump (if needed)**

```bash
git log --oneline -10
```

Review commits and ensure everything is in order.

---

## Summary

This plan creates PAGI::SSE with:

1. **Constructor** - Validates scope, stores receive/send
2. **State** - pending/started/closed tracking
3. **Start** - Sends sse.start with optional status/headers
4. **Send methods** - send, send_json, send_event
5. **Safe sends** - try_send_* variants
6. **Lifecycle** - on_close, close, run
7. **Reconnection** - last_event_id helper
8. **Keepalive** - Periodic comment pings
9. **Iteration** - each() helper for streaming
10. **Documentation** - Full POD
11. **Example** - Live dashboard demo

Total: ~13 tasks, each with TDD approach and commits.
